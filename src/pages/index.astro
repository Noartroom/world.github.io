---
import Layout from '@/layouts/Layout.astro';
import Renderer from '@/components/Renderer.astro';
---
<Layout title="Astro Prototype">
  <main>
    <div class="scene-viewport">
      <!-- Layer -1: Background World (Lines/Structure) -->
      <div id="world-background-container">
        
        <!-- Layer (0,0,0) [Back/Deep] -->
        <div id="bg-layer-back" class="world-layer" data-x="0" data-y="0" data-z="0">
          <div class="room-content">
             <div class="layer-background">
                 <div class="cube-container">
                    <div class="cube static-cube">
                      <div class="face front"></div>
                      <div class="face back"></div>
                      <div class="face right"></div>
                      <div class="face left"></div>
                      <div class="face top"></div>
                      <div class="face bottom"></div>
                    </div>
                 </div>
             </div>
          </div>
        </div>

        <!-- Layer (0,0,1) [Front/Top] -->
        <div id="bg-layer-front" class="world-layer" data-x="0" data-y="0" data-z="1">
          <div class="room-content">
              <div class="layer-background">
                 <div class="cube-container room-visual">
                    <div class="cube static-cube">
                      <div class="face front"></div>
                      <div class="face back"></div>
                      <div class="face right"></div>
                      <div class="face left"></div>
                      <div class="face top"></div>
                      <div class="face bottom"></div>
                    </div>
                 </div>
              </div>
          </div>
        </div>
        
      </div>

      <!-- Layer 0: The 3D Scene (Renderer/Model) -->
      <div class="renderer-layer">
        <Renderer />
      </div>
    </div>

    <!-- Persistent UI: Always on top (Buttons) -->
    <div id="layer-persistent">
      
      <!-- Spatial Navigation (Right Side Stack) -->
      <div class="spatial-nav-right">
          <!-- In (Forward) -->
          <button id="nav-forward" class="nav-btn-circle" aria-label="Move In">
              <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M12 4L12 16M12 4L8 8M12 4L16 8M4 20H20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
          
          <!-- Horizontal Row: Left / Cube / Right -->
          <div class="nav-horizontal-row">
              <button id="nav-left" class="nav-btn-circle" aria-label="Move Left">
                  <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor" style="transform: rotate(-90deg)"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
              </button>
              
              <!-- Indicator Cube (Center) -->
              <div class="indicator-stack">
                  <div class="mini-map" id="mini-map-desktop">
                      <!-- Layer (0,0,1) Front -->
                      <button class="mini-cube" data-x="0" data-y="0" data-z="1" aria-label="Go to Front Layer">
                        <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                        <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                        <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                      </button>
                      <!-- Layer (0,0,0) Back -->
                      <button class="mini-cube" data-x="0" data-y="0" data-z="0" aria-label="Go to Back Layer">
                         <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                         <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                         <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                      </button>
                      <!-- Layer (1,0,0) Right -->
                      <button class="mini-cube" data-x="1" data-y="0" data-z="0" aria-label="Go to Right Layer">
                         <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                         <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                         <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                      </button>
                  </div>
                  <div id="coords-desktop" class="coords-display">0,0,0</div>
              </div>

              <button id="nav-right" class="nav-btn-circle" aria-label="Move Right">
                  <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor" style="transform: rotate(90deg)"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
              </button>
          </div>

          <!-- Out (Backward) -->
          <button id="nav-backward" class="nav-btn-circle" aria-label="Move Out">
              <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M12 20L12 8M12 20L8 16M12 20L16 16M4 4H20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
      </div>

      <!-- Top Bar: Toggles only -->
      <nav class="global-controls" aria-label="Global Controls">
        <button id="themeToggle" class="global-toggle" aria-label="Toggle Dark/Light Theme" aria-pressed="false">Theme</button>
        <button id="modelToggle" class="global-toggle" aria-label="Switch 3D Model" aria-pressed="false">Model</button>
        <button id="blob-toggle" class="global-toggle" aria-label="Toggle Light Blob Effect" aria-pressed="false">Light</button>
        
        <div class="divider"></div>

        <div id="time-display" class="global-toggle time-control" tabindex="0" role="slider" aria-label="Time of Day Control. Swipe up/down to change time." aria-valuemin="0" aria-valuemax="24" aria-valuenow="12" aria-valuetext="12:00 UTC">
          <div class="time-visual" id="time-visual" aria-hidden="true">
            <div class="time-visual-orb"></div>
          </div>
          <span class="time-value">12:00</span>
        </div>
      </nav>

      <!-- Mobile Nav (Map Only) -->
      <div class="layer-nav-mobile" id="layer-nav-mobile-container">
        <!-- Reusing the mini-map structure for mobile, positioned bottom right -->
        <div class="mobile-map-container">
             <div class="mini-map mobile-mode" id="mini-map-mobile">
                  <!-- Layer (0,0,1) Front -->
                  <button class="mini-cube" data-x="0" data-y="0" data-z="1" aria-label="Go to Front Layer">
                    <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                    <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                    <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                  </button>
                  <!-- Layer (0,0,0) Back -->
                  <button class="mini-cube" data-x="0" data-y="0" data-z="0" aria-label="Go to Back Layer">
                     <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                     <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                     <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                  </button>
                  <!-- Layer (1,0,0) Right -->
                  <button class="mini-cube" data-x="1" data-y="0" data-z="0" aria-label="Go to Right Layer">
                     <div class="mc-face mc-front"></div><div class="mc-face mc-back"></div>
                     <div class="mc-face mc-right"></div><div class="mc-face mc-left"></div>
                     <div class="mc-face mc-top"></div><div class="mc-face mc-bottom"></div>
                  </button>
              </div>
             <div id="coords-mobile" class="coords-display">0,0,0</div>
        </div>
      </div>
    </div>
  </main>
</Layout>

<script>
  // @ts-nocheck
  // This script controls the global buttons
  import { theme, activeModel, isBlobActive, activeLayer, getAvailableMoves, isLayerValid } from '../lib/stores/sceneStore';
  import { timeStore, changeTime } from '../lib/stores/timeStore';

  const themeButton = document.getElementById('themeToggle');
  themeButton?.addEventListener('click', () => {
    const currentTheme = theme.get();
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    theme.set(newTheme);
  });

  theme.subscribe(newTheme => {
    if (newTheme === 'light') {
      document.body.classList.add('light-mode');
      document.body.classList.remove('dark-mode');
    } else {
      document.body.classList.add('dark-mode');
      document.body.classList.remove('light-mode');
    }
    if (themeButton) {
      themeButton.setAttribute('aria-pressed', (newTheme === 'dark').toString());
    }
  });

  const modelButton = document.getElementById('modelToggle');
  modelButton?.addEventListener('click', () => {
    const current = activeModel.get();
    const newModel = current === 'light' ? 'dark' : 'light';
    if (current !== newModel) {
      activeModel.set(newModel);
    }
  });

  activeModel.subscribe(model => {
    if (modelButton) {
      modelButton.setAttribute('aria-pressed', (model === 'dark').toString());
    }
  });

  const blobButton = document.getElementById('blob-toggle');
  blobButton?.addEventListener('click', () => {
    isBlobActive.set(!isBlobActive.get());
  });

  isBlobActive.subscribe(active => {
    if (blobButton) {
      blobButton.setAttribute('aria-pressed', active.toString());
    }
  });

  // --- Spatial Navigation Logic ---
  
  // Map buttons to vectors (Up/Down removed)
  const navActions = {
      'nav-left': { dx: -1, dy: 0, dz: 0 },
      'nav-right': { dx: 1, dy: 0, dz: 0 },
      // Swapped up/down semantics: forward now goes outward (+Z), backward goes inward (-Z)
      'nav-forward': { dx: 0, dy: 0, dz: 1 },  // +Z (Out)
      'nav-backward': { dx: 0, dy: 0, dz: -1 }, // -Z (Deep)
  };

  // Attach Listeners
  Object.entries(navActions).forEach(([id, delta]) => {
      const btn = document.getElementById(id);
      if (btn) {
          btn.addEventListener('click', () => {
             const current = activeLayer.get();
             const target = { x: current.x + delta.dx, y: current.y + delta.dy, z: current.z + delta.dz };
             
             if (isLayerValid(target.x, target.y, target.z)) {
                 activeLayer.set(target); // Seamless CSS transition
             }
          });
      }
  });

  // Attach Listeners for Mini Map Cubes
  document.querySelectorAll('.mini-cube').forEach(cube => {
      cube.addEventListener('click', (e) => {
          const x = parseInt(cube.dataset.x);
          const y = parseInt(cube.dataset.y);
          const z = parseInt(cube.dataset.z);
          
          if (isLayerValid(x, y, z)) {
              activeLayer.set({ x, y, z });
          }
      });
  });

  // Subscribe to layer changes
  activeLayer.subscribe(coords => {
    const isBack = coords.z === 0;
    
    // Update body class
    const isFront = coords.z === 1 && coords.x === 0 && coords.y === 0;
    document.body.classList.toggle('layer-back-active', !isFront);
    document.body.classList.toggle('layer-front-active', isFront);

    // 1. Update Navigation Button Visibility (Desktop Arrows)
    const moves = getAvailableMoves(coords);
    
    const updateButton = (id, available) => {
        const btn = document.getElementById(id);
        if (btn) {
            // Using opacity/pointer-events instead of display:none to prevent layout shift
            if (available) {
                btn.classList.remove('disabled');
                btn.removeAttribute('disabled');
                btn.setAttribute('aria-hidden', 'false');
            } else {
                btn.classList.add('disabled');
                btn.setAttribute('disabled', 'true');
                btn.setAttribute('aria-hidden', 'true');
            }
        }
    };

    updateButton('nav-left', moves.left);
    updateButton('nav-right', moves.right);
    updateButton('nav-forward', moves.forward);
    updateButton('nav-backward', moves.backward);

    const worldBgContainer = document.getElementById('world-background-container');
    // Background: apply a simple, cheap translate to hint movement
    if (worldBgContainer) {
      const tx = coords.x * -100; // vw shift per room (horizontal)
      const ty = coords.y * -100; // vh shift per room (vertical) â€” extendable
      const depthScale = 1 + coords.z * 0.02; // subtle depth hint per z step
      worldBgContainer.style.transform = `translate(${tx}vw, ${ty}vh) scale(${depthScale})`;
    }

    // 3. Update Mini Map Active State
    document.querySelectorAll('.mini-cube').forEach(cube => {
        const x = parseInt(cube.dataset.x);
        const y = parseInt(cube.dataset.y);
        const z = parseInt(cube.dataset.z);
        // Simple equality check
        if (x === coords.x && y === coords.y && z === coords.z) {
            cube.classList.add('active');
            cube.setAttribute('aria-current', 'true');
        } else {
            cube.classList.remove('active');
            cube.removeAttribute('aria-current');
        }
    });

    // 4. Update Coordinate Display
    const coordText = `${coords.x},${coords.y},${coords.z}`;
    const coordsDesktop = document.getElementById('coords-desktop');
    const coordsMobile = document.getElementById('coords-mobile');
    if (coordsDesktop) coordsDesktop.textContent = coordText;
    if (coordsMobile) coordsMobile.textContent = coordText;

    // 5. Inert Logic
    const layerFront = document.getElementById('layer-front');
    if (layerFront) {
        if (isFront) {
            layerFront.removeAttribute('inert');
        } else {
            layerFront.setAttribute('inert', '');
        }
    }
  });

  const timeDisplay = document.getElementById('time-display');
  const timeValue = timeDisplay?.querySelector('.time-value');
  const timeVisual = timeDisplay?.querySelector('.time-visual') as HTMLElement | null;
  const timeVisualOrb = timeVisual?.querySelector('.time-visual-orb') as HTMLElement | null;
  const getCurrentWallClockHours = () => {
    const now = new Date();
    return now.getHours() + now.getMinutes() / 60 + now.getSeconds() / 3600 + now.getMilliseconds() / 3600000;
  };
  function formatTime(hours) {
    const h = Math.floor(hours);
    const m = Math.floor((hours - h) * 60);
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
  }

  const clamp01 = (v: number) => Math.min(1, Math.max(0, v));
  const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
  const lerpColor = (c1: [number, number, number], c2: [number, number, number], t: number) => {
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t)),
    ];
  };

  function sampleSky(hours: number) {
    // Keyframe palette across the day; hours wrap 0-24
    const stops = [
      { hour: 0,  top: [10, 16, 40], bottom: [6, 10, 26], orb: [170, 190, 255] },   // night
      { hour: 5,  top: [30, 46, 92], bottom: [86, 70, 108], orb: [255, 200, 140] }, // dawn
      { hour: 8,  top: [108, 166, 232], bottom: [194, 226, 255], orb: [255, 225, 180] }, // morning
      { hour: 12, top: [130, 192, 255], bottom: [208, 236, 255], orb: [255, 232, 190] }, // noon
      { hour: 17, top: [255, 178, 128], bottom: [92, 52, 104], orb: [255, 170, 120] }, // dusk
      { hour: 20, top: [18, 24, 62], bottom: [7, 9, 28], orb: [180, 200, 255] },     // evening
      { hour: 24, top: [10, 16, 40], bottom: [6, 10, 26], orb: [170, 190, 255] },    // wrap to night
    ];

    let i = stops.findIndex((stop, idx) => hours >= stop.hour && hours < stops[idx + 1]?.hour);
    if (i === -1) i = stops.length - 2; // between last and wrap
    const a = stops[i];
    const b = stops[i + 1] ?? stops[0];
    const span = (b.hour - a.hour) || 24;
    const t = ((hours - a.hour + 24) % 24) / span;

    return {
      top: lerpColor(a.top as [number, number, number], b.top as [number, number, number], t),
      bottom: lerpColor(a.bottom as [number, number, number], b.bottom as [number, number, number], t),
      orb: lerpColor(a.orb as [number, number, number], b.orb as [number, number, number], t),
    };
  }

  function updateTimeVisual(hours: number) {
    if (!timeVisual || !timeVisualOrb) return;

    const palette = sampleSky(hours);

    // Sun visibility peaks at noon; zero at 6 and 18
    const sunPhase = (hours - 6) / 12;
    const sunAltitude = sunPhase >= 0 && sunPhase <= 1 ? Math.sin(Math.PI * sunPhase) : 0;
    const sunStrength = clamp01(sunAltitude);
    const sunX = clamp01(sunPhase);
    const sunY = 0.75 - sunStrength * 0.5; // lower when higher in sky

    // Moon peaks around midnight; zero near 6 and 18
    const nightPhase = hours >= 18 ? (hours - 18) / 12 : (hours + 6) / 12;
    const moonAltitude = nightPhase >= 0 && nightPhase <= 1 ? Math.sin(Math.PI * nightPhase) : 0;
    const moonStrength = clamp01(moonAltitude);
    const moonX = clamp01(nightPhase);
    const moonY = 0.65 - moonStrength * 0.35;

    const total = sunStrength + moonStrength || 1;
    const orbX = (sunStrength * (0.12 + 0.76 * sunX) + moonStrength * (0.12 + 0.76 * moonX)) / total;
    const orbY = (sunStrength * sunY + moonStrength * moonY) / total;
    const orbColor = lerpColor([255, 214, 120], [185, 210, 255], moonStrength / total);

    const skyTop = `rgb(${palette.top.join(',')})`;
    const skyBottom = `rgb(${palette.bottom.join(',')})`;
    timeVisual.style.setProperty('--tv-sky-top', skyTop);
    timeVisual.style.setProperty('--tv-sky-bottom', skyBottom);
    timeVisual.style.setProperty('--tv-orb-x', `${(orbX * 100).toFixed(1)}%`);
    timeVisual.style.setProperty('--tv-orb-y', `${(orbY * 100).toFixed(1)}%`);
    timeVisual.style.setProperty('--tv-stars-opacity', moonStrength.toFixed(2));

    const orb = `rgb(${orbColor.join(',')})`;
    timeVisualOrb.style.background = orb;
    timeVisualOrb.style.boxShadow = `0 0 6px 0 ${orb}`;
  }

  timeStore.subscribe(value => {
    if (timeValue) {
      timeValue.textContent = formatTime(value);
    }
    if (timeDisplay) {
      timeDisplay.setAttribute('aria-valuenow', value.toString());
      timeDisplay.setAttribute('aria-valuetext', formatTime(value));
    }
    updateTimeVisual(value);
  });
  updateTimeVisual(timeStore.get());

  const AUTO_TIME_INTERVAL_MS = 60_000;
  let timeAutoTick: number | null = null;
  let timeAlignTimeout: number | null = null;
  let timeOffset = timeStore.get() - getCurrentWallClockHours(); // preserve user-set offset relative to real clock
  let isAutoTick = false;

  const applyAutoTime = () => {
    isAutoTick = true;
    timeStore.set(getCurrentWallClockHours() + timeOffset);
    isAutoTick = false;
  };

  const startAutoTimeUpdates = () => {
    if (timeAutoTick !== null) return;
    // initial sync
    applyAutoTime();
    const alignDelay = AUTO_TIME_INTERVAL_MS - (Date.now() % AUTO_TIME_INTERVAL_MS);
    timeAlignTimeout = window.setTimeout(() => {
      applyAutoTime();
      timeAutoTick = window.setInterval(applyAutoTime, AUTO_TIME_INTERVAL_MS);
    }, alignDelay);
  };

  const stopAutoTimeUpdates = () => {
    if (timeAutoTick !== null) {
      clearInterval(timeAutoTick);
      timeAutoTick = null;
    }
    if (timeAlignTimeout !== null) {
      clearTimeout(timeAlignTimeout);
      timeAlignTimeout = null;
    }
  };

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      applyAutoTime();
    }
  });

  startAutoTimeUpdates();
  window.addEventListener('beforeunload', stopAutoTimeUpdates);

  if (timeDisplay) {
    timeDisplay.addEventListener('wheel', (e) => {
      e.preventDefault();
      const magnitude = Math.abs(e.deltaY);
      let increment = 0.25;
      if (magnitude > 50) increment = 1.0;
      const delta = e.deltaY > 0 ? increment : -increment;
      changeTime(delta);
    }, { passive: false });

    timeDisplay.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
        e.preventDefault();
        changeTime(0.5);
      } else if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
        e.preventDefault();
        changeTime(-0.5);
      }
    });

    let touchStartY = 0;
    timeDisplay.addEventListener('touchstart', (e) => {
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    timeDisplay.addEventListener('touchmove', (e) => {
       if (e.cancelable) e.preventDefault();
       const currentY = e.touches[0].clientY;
       const deltaY = currentY - touchStartY;
       if (Math.abs(deltaY) > 5) {
           const direction = deltaY > 0 ? -1 : 1;
           changeTime(direction * 0.15);
           touchStartY = currentY;
       }
    }, { passive: false });
  }

</script>

<script is:inline>
  let idleTimer;
  let idleTimeoutDuration = 30000;
  let lastMouseX = 0;
  let lastMouseY = 0;

  function resetIdleTimer() {
    if (document.body.classList.contains('user-idle')) {
      document.body.classList.remove('user-idle');
    }
    clearTimeout(idleTimer);
    idleTimer = window.setTimeout(() => {
      document.body.classList.add('user-idle');
      idleTimeoutDuration = 10000;
    }, idleTimeoutDuration);
  }

  function handleMouseMove(e) {
    if (Math.abs(e.clientX - lastMouseX) > 2 || Math.abs(e.clientY - lastMouseY) > 2) {
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      resetIdleTimer();
    }
  }

  const userEvents = ['mousedown', 'click', 'keypress', 'touchstart', 'touchmove', 'wheel', 'scroll'];
  userEvents.forEach(event => {
    window.addEventListener(event, resetIdleTimer, { passive: true });
  });
  window.addEventListener('mousemove', handleMouseMove, { passive: true });
  resetIdleTimer();
</script>

<style>
main {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: transparent;
    position: relative;
    display: flex;
    align-items: stretch;
    justify-content: center;
    /* perspective moved to .scene-viewport to fix mobile rendering */
  }

  .scene-viewport {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    justify-content: stretch;
    width: 100%;
    height: 100%;
    perspective: 1000px; /* Global Perspective for 3D Layers */
    transform-style: flat; /* flatten to avoid nested 3D over canvas */
    overflow: hidden;
  }

  /* SIMPLIFICATION FOR MOBILE DEBUGGING */
  @media (max-width: 768px) {
    .scene-viewport {
        perspective: none;
        transform-style: flat;
    }
    
    /* Hide the complex 3D background on mobile to isolate rendering bugs */
    #world-background-container {
        display: none !important;
    }
    
    /* Simplify the foreground container to avoid interference */
    #world-container {
        transform-style: flat !important;
        transform: none !important;
    }

  }

  /* --- 3D Background Container (Lines) --- */
  #world-background-container {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-style: flat; /* Flatten to reduce overdraw */
      transition: transform 0.35s ease-out; /* lightweight translate only */
      /* will-change removed to prevent Safari stacking context issues */
      z-index: -1; /* Behind renderer */
      pointer-events: none;
  }

  .renderer-layer {
      position: absolute;
      inset: 0;
      z-index: 0; /* above background, below foreground */
      pointer-events: auto;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
  }

  /* Layer Base Styles */
  .world-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Room Content Wrapper */
  .room-content {
      width: 100%; height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
  }

  .layer-background {
      position: absolute;
      inset: 0;
      pointer-events: none; /* Always pass through */
      display: flex;
      justify-content: center;
      align-items: center;
  }

  .layer-foreground {
      position: relative;
      z-index: 10;
      pointer-events: none;
      text-align: center;
      margin-top: 10vh; /* Move text into upper third */
      color: white;
      text-shadow: 0 2px 10px rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 0.35rem;
  }

  .layer-foreground h1,
  .layer-foreground h2,
  .layer-foreground p {
      pointer-events: auto;
      max-width: fit-content;
      margin-left: auto;
      margin-right: auto;
  }

  /* Reduce font size on mobile */
  @media (max-width: 768px) {
      .layer-foreground h2 {
          font-size: 1.5rem !important;
      }
  }

  .layer-foreground h2 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
  }

  /* Landscape Mobile Adjustment */
  @media (max-height: 500px) {
      .layer-foreground {
          margin-top: 0 !important;
      }
  }

  .layer-foreground p {
      opacity: 0.8;
  }

  /* --- Layer Placement --- */
  
  /* Background layers remain static in Z (no translate) */
  #bg-layer-back { transform: none; }
  #bg-layer-front { transform: none; }

  /* --- Persistent UI --- */
  #layer-persistent {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 0;
    z-index: 100;
    pointer-events: none;
  }

  .content-box {
      padding: 2rem;
      color: white;
      pointer-events: none;
  }

  /* --- Navigation Controls --- */
  .global-controls {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
    pointer-events: auto;
    padding: 0.5rem;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(20px);
    z-index: 1000;
    box-shadow: 0 0 30px rgba(0,0,0,0.5);
  }

  /* --- Right Side Navigation (Desktop) --- */
  .spatial-nav-right {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem; /* Space between In, Cross, Out */
      z-index: 1000;
      pointer-events: none; /* Pass clicks through the container gaps */
  }

  /* Updated layout: Horizontal Row for Left-Cube-Right */
  .nav-horizontal-row {
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: none;
  }

  .nav-btn-circle {
      width: 50px; height: 50px;
      border-radius: 50%;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s ease;
      /* backdrop-filter removed to fix visual glitch on 3D background */
      padding: 0;
      pointer-events: auto; /* Buttons must be clickable */
  }


  /* Disabled State: Grayed out but visible */
  .nav-btn-circle.disabled {
      opacity: 0.3;
      pointer-events: none;
      cursor: not-allowed;
      transform: none;
      filter: grayscale(100%);
  }

  .global-toggle {
      padding: 0.5em 1em;
      background: rgba(68, 68, 68, 0.8);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.1);
      /* backdrop-filter removed to fix visual glitch on 3D background */
      transition: all 0.2s ease-out;
      cursor: pointer;
      border-radius: 6px;
  }


  /* Invisible but layout-preserving disabled state */
  .global-toggle.disabled {
      opacity: 0.3;
      pointer-events: none;
  }

  /* --- 3D Indicator --- */
  .layer-indicator-3d {
      width: 32px;
      height: 32px;
      perspective: 100px;
      pointer-events: auto; /* Maybe clickable later, but safe for now */
  }
  
  .indicator-cube {
      width: 100%; height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transform: rotateX(0deg) rotateY(45deg); /* Static View */
      transition: transform 0.5s ease;
  }

  .ind-face {
      position: absolute;
      width: 16px; height: 16px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      top: 8px; left: 8px;
      transition: all 0.3s ease;
  }
  
  /* Highlight Available Faces */
  .ind-face.available {
      background: transparent;
      border-color: rgba(88, 166, 255, 0.8);
      box-shadow: none;
  }

  .ind-front { transform: translateZ(8px); }
  .ind-back  { transform: rotateY(180deg) translateZ(8px); }
  .ind-right { transform: rotateY(90deg) translateZ(8px); }
  .ind-left  { transform: rotateY(-90deg) translateZ(8px); }
  .ind-top   { transform: rotateX(90deg) translateZ(8px); }
  .ind-bottom{ transform: rotateX(-90deg) translateZ(8px); }

  .ind-dot {
      position: absolute;
      width: 4px; height: 4px;
      background: #fff;
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px #fff;
  }

  .divider {
    width: 1px;
    height: 20px;
    background: rgba(255, 255, 255, 0.1);
    margin: 0 0.5rem;
  }

  /* --- Mobile Navigation --- */
  .layer-nav-mobile {
     display: none; /* Hidden on desktop */
  }

  @media (max-width: 768px) {
      .spatial-nav-desktop {
          display: none;
      }
      .spatial-nav-right {
          display: none; /* Hide desktop nav on mobile */
      }
      
      .layer-nav-mobile {
          display: flex;
          position: fixed; /* Fixed viewport positioning */
          inset: 0;
          height: 100vh;
          pointer-events: none; /* Container passes clicks */
          z-index: 900;
          align-items: center;
          justify-content: center;
      }

      .mobile-nav-btn {
          position: absolute;
          pointer-events: auto; /* Buttons are clickable */
          background: rgba(0,0,0,0.5);
          color: white;
          border: 1px solid rgba(255,255,255,0.2);
          width: 50px; height: 50px;
          border-radius: 50%;
          display: flex;
          justify-content: center;
          align-items: center;
          transition: all 0.3s ease;
      }

      .mobile-nav-btn.hidden {
          opacity: 0;
          pointer-events: none;
      }

      .pos-top { top: 80px; left: 50%; transform: translateX(-50%); }
      .pos-bottom { bottom: 40px; left: 50%; transform: translateX(-50%); }
      .pos-left { top: 50%; left: 20px; transform: translateY(-50%); }
      .pos-right { top: 50%; right: 20px; transform: translateY(-50%); }

      .mobile-depth-controls {
          position: absolute;
          bottom: 40px;
          right: 20px;
          display: flex;
          flex-direction: column;
          gap: 1rem;
          pointer-events: none; /* Container passes clicks */
      }
      
      .mobile-depth-controls .mobile-nav-btn {
          position: relative;
          width: 40px; height: 40px;
          inset: auto; transform: none;
          pointer-events: auto;
      }
  }

  .cube-container {
    --box-w: 80vmin;
    --box-h: 80vmin;
    --box-d: 80vmin;
    width: var(--box-w);
    height: var(--box-h);
    perspective: 1000px;
    margin: 0 auto;
    pointer-events: none !important; /* Ensure passthrough */
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Static Cube for Decor */
  .static-cube {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transform: rotateY(0deg); /* Static room alignment (No Tilt) */
    animation: none; /* Disable spinning */
    pointer-events: none !important;
  }

  .face {
    position: absolute;
    background: transparent; /* Strip gradients */
    border: 1px solid rgba(255, 255, 255, 0.1);
    pointer-events: none !important;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: center;
    -webkit-backface-visibility: visible;
    backface-visibility: visible;
    box-shadow: none !important; /* Strip inset shadows */
  }

  :global(.light-mode) .face {
    border: 1px solid rgba(0, 0, 0, 0.1);
    background: transparent;
  }

  .front, .back { width: var(--box-w); height: var(--box-h); }
  .front  { transform: rotateY(0deg) translateZ(calc(var(--box-d) / 2)); }
  .back   { transform: rotateY(180deg) translateZ(calc(var(--box-d) / 2)); }
  
  .right, .left { width: var(--box-d); height: var(--box-h); }
  .right  { transform: rotateY(90deg) translateZ(calc(var(--box-w) / 2)); }
  .left   { transform: rotateY(-90deg) translateZ(calc(var(--box-w) / 2)); }
  
  .top, .bottom { width: var(--box-w); height: var(--box-d); }
  .top    { transform: rotateX(90deg) translateZ(calc(var(--box-h) / 2)); }
  .bottom { transform: rotateX(-90deg) translateZ(calc(var(--box-h) / 2)); }

  /* Time Control */
  .time-control {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    cursor: ns-resize;
    user-select: none;
    touch-action: none;
    min-width: 100px;
  }

  /* Reduce size for time/city on mobile */
  @media (max-width: 768px) {
      .time-control {
          gap: 0.5rem;
          min-width: auto;
      }
      .time-value {
          font-size: 0.8rem;
      }
  }
  .time-value { font-family: monospace; font-weight: bold; }
  .time-visual {
      position: relative;
      width: 48px;
      height: 20px;
      border-radius: 999px;
      overflow: hidden;
      background: linear-gradient(180deg, var(--tv-sky-top, #0b1c3f), var(--tv-sky-bottom, #060c22));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
      flex-shrink: 0;
      transition: background 0.6s ease;
  }
  .time-visual::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image:
        radial-gradient(1px 1px at 20% 30%, rgba(255,255,255,0.8), transparent),
        radial-gradient(1px 1px at 60% 60%, rgba(255,255,255,0.5), transparent),
        radial-gradient(1px 1px at 80% 20%, rgba(255,255,255,0.7), transparent);
      opacity: var(--tv-stars-opacity, 0);
      transition: opacity 0.6s ease;
      pointer-events: none;
  }
  .time-visual-orb {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f5d76e;
      box-shadow: 0 0 6px 0 #f5d76e;
      transform: translate(calc(var(--tv-orb-x, 50%) - 50%), calc(var(--tv-orb-y, 50%) - 50%));
      transition: transform 0.6s ease, background 0.6s ease, box-shadow 0.6s ease;
      will-change: transform;
    }
  
  /* --- Coordinates Display --- */
  .indicator-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
  }

  .coords-display {
      font-family: monospace;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.7);
      text-align: center;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      white-space: nowrap;
  }

  /* --- Mini Map Navigation --- */
  .mini-map {
      position: relative;
      width: 60px;
      height: 60px;
      transform-style: preserve-3d; /* restore cube visualization */
      /* Sideways, but keep 3D depth (less diagonal than original) */
      transform: rotateX(75deg)rotateZ(20deg);
      transition: transform 0.5s ease;
      margin-bottom: 10px;
  }

  .mini-cube {
      position: absolute;
      width: 16px;
      height: 16px;
      background: transparent;
      border: none;
      padding: 0;
      transform-style: preserve-3d;
      cursor: pointer;
      top: 50%; left: 50%;
      margin-top: -8px; margin-left: -8px; /* Center anchor */
      transition: transform 0.3s ease, opacity 0.3s;
      /* Fix for preserving 3d space in button */
      display: block;
      touch-action: manipulation; /* Improve touch response */
      -webkit-tap-highlight-color: transparent; /* Remove gray tap box */
      outline: none; /* Remove focus ring */
      user-select: none;
  }
  /* Larger hit target without changing visual size */
  .mini-cube::after {
      content: '';
      position: absolute;
      inset: -8px; /* expands clickable area */
      background: transparent;
      pointer-events: auto;
      cursor: pointer;
  }
  

  /* Coordinate Mapping (Mini Scale) */
  /* Scale: Minimum spacing (20px for 16px cubes = 4px gap) */
  /* Note: We need to combine position transform with hover scale if we want hover scale.
     For now, we just set base position.
  */
  .mini-cube[data-z="1"] { transform: translate3d(0, 0, 20px); } /* Front */
  .mini-cube[data-z="0"] { transform: translate3d(0, 0, 0); }    /* Back */
  .mini-cube[data-x="1"] { transform: translate3d(20px, 0, 0); }  /* Right */

  /* Faces */
  .mc-face {
      position: absolute;
      width: 100%; height: 100%;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-sizing: border-box;
      /* backface-visibility removed */
      pointer-events: none;
      transition: all 0.3s ease;
  }

  /* Light Theme Override */
  :global(.light-mode) .mc-face {
      background: transparent;
      border: 1px solid rgba(0, 0, 0, 0.2);
  }

  .mini-cube.active .mc-face {
      background: transparent;
      border: 1px solid rgba(88, 166, 255, 0.9);
      box-shadow: none;
  }

  .mc-front  { transform: rotateY(0deg) translateZ(8px); }
  .mc-back   { transform: rotateY(180deg) translateZ(8px); }
  .mc-right  { transform: rotateY(90deg) translateZ(8px); }
  .mc-left   { transform: rotateY(-90deg) translateZ(8px); }
  .mc-top    { transform: rotateX(90deg) translateZ(8px); }
  .mc-bottom { transform: rotateX(-90deg) translateZ(8px); }

  /* Mobile Specifics */
  .mobile-map-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      position: relative;
      margin: 0 auto;
  }

  /* Mobile regular 3D mode positioning: map bottom-right, coords bottom-left */
  @media (max-width: 768px) {
      :global(body:not(.fallback-mode)) .layer-nav-mobile {
          align-items: stretch;
          justify-content: stretch;
      }
      :global(body:not(.fallback-mode)) .mobile-map-container {
          position: fixed;
          inset: 0;
          pointer-events: none;
      }
      :global(body:not(.fallback-mode)) .mobile-map-container .mini-map {
          position: absolute;
          bottom: 16px;
          right: 16px;
          pointer-events: auto;
      }
      :global(body:not(.fallback-mode)) #coords-mobile {
          position: absolute;
          bottom: 16px;
          left: 16px;
          pointer-events: none;
      }
  }

  /* Make it larger on mobile */
  .mini-map.mobile-mode {
      width: 120px;
      height: 120px;
      transform-style: preserve-3d; /* restore cube visualization */
      /* Match desktop sideways view with preserved 3D depth */
      transform: rotateX(75deg)rotateZ(20deg);
  }

  .mini-map.mobile-mode .mini-cube {
      width: 36px;
      height: 36px;
      margin-top: -18px; margin-left: -18px;
  }
  /* Increase mobile hit target further */
  .mini-map.mobile-mode .mini-cube::after {
      inset: -12px;
      cursor: pointer;
  }
  
  .mini-map.mobile-mode .mc-front  { transform: rotateY(0deg) translateZ(18px); }
  .mini-map.mobile-mode .mc-back   { transform: rotateY(180deg) translateZ(18px); }
  .mini-map.mobile-mode .mc-right  { transform: rotateY(90deg) translateZ(18px); }
  .mini-map.mobile-mode .mc-left   { transform: rotateY(-90deg) translateZ(18px); }
  .mini-map.mobile-mode .mc-top    { transform: rotateX(90deg) translateZ(18px); }
  .mini-map.mobile-mode .mc-bottom { transform: rotateX(-90deg) translateZ(18px); }

  /* Mobile Positioning Scale (40px for 36px cubes = 4px gap) */
  .mini-map.mobile-mode .mini-cube[data-z="1"] { transform: translate3d(0, 0, 40px); }
  .mini-map.mobile-mode .mini-cube[data-z="0"] { transform: translate3d(0, 0, 0); }
  .mini-map.mobile-mode .mini-cube[data-x="1"] { transform: translate3d(40px, 0, 0); }

  /* Adjustments for mobile to ensure spacing */
  .mobile-depth-controls .coords-display {
      margin-top: -8px; /* Pull it up closer to cube if needed, or adjust spacing in parent */
      margin-bottom: 4px;
  }

</style>
