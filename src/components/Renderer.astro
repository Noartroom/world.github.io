---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, IMAGE3D-1, dezimiertt-glb-03
const { modelPath = "/models/modernart1-sculpt-1.glb" } = Astro.props;
---

<div class="renderer-container" aria-label="Interactive 3D Model Viewer" role="application">
  <div id="loader" class="loader">INITIALIZING GPU...</div>
  <div id="debug-overlay" style="position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none; font-family: monospace; z-index: 9999;">
      Waiting for audio data...
  </div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
  <div class="css-light-overlay"></div>
</div>

<script type="module" define:vars={{ CANVAS_ID, modelPath }}>
  import init, { startRenderer } from '/pkg/model_renderer.js?v=gpu_fix_6';
  import { theme, activeModel, onSet, isDynamicLightActive } from '../src/stores/sceneStore.ts';
  import { getAudioData, getStereoData } from '../src/stores/audioStore.ts';

  // --- Global Scope (f√ºr Cleanup notwendig) ---
  let state = null;
  let rafId = null;
  let resizeObserver = null;
  let intersectionObserver = null;
  let isVisible = true;
  let themeUnsub = null;
  let lightUnsub = null;
  let modelUnsub = null;
  let isLoadingModel = false; // Prevent concurrent model loads

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  let frameTimer = 0;
  let frameCount = 0;
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;

  // DOM Elemente
  const canvas = document.getElementById(CANVAS_ID);
  const container = document.querySelector('.renderer-container');
  const loader = document.getElementById('loader');

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;

  // --- SOTA Render Loop ---
  function renderLoop(timestamp) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Monitor Frame Time
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Einfacher FPS Counter √ºber 1 Sekunde
    frameTimer += delta;
    frameCount++;
    
    if (frameTimer >= 1000) {
      const fps = frameCount;
      // console.log(`FPS: ${fps}, DPR: ${currentDpr.toFixed(2)}`);
      
      // Dynamic Resolution Scaling (Tiered)
      // Wenn FPS unter 45 fallen, reduziere Aufl√∂sung (min 0.5)
      if (fps < 45 && currentDpr > 0.5) {
         targetDpr = Math.max(0.5, currentDpr - 0.25);
         triggerResize(); // Trigger resize with new DPR
      }
      // Wenn FPS stabil bei 60 sind, versuche Qualit√§t zu erh√∂hen (bis native DPR)
      else if (fps >= 58 && currentDpr < (window.devicePixelRatio || 1)) {
         targetDpr = Math.min(window.devicePixelRatio || 1, currentDpr + 0.1);
         triggerResize();
      }
      
      frameTimer = 0;
      frameCount = 0;
    }

    if (state) {
      try {
        // Pass audio data to WASM
        try {
            const audioData = getAudioData();
            const stereo = getStereoData();

            if (audioData && audioData.length > 0 && audioData instanceof Uint8Array) {
                const sum = audioData.reduce((a, b) => a + b, 0);
                const avg = sum / audioData.length;
                
                // avg is roughly 0-100, max 255.
                const intensity = Math.min(avg / 80.0, 1.0); // Increased sensitivity

                // Calculate Panning (Balance)
                // -1.0 (Left) to 1.0 (Right)
                // Avoid division by zero
                const totalVol = (stereo.left + stereo.right) || 1;
                const balance = (stereo.right - stereo.left) / totalVol;
                
                // Smooth panning to avoid jitter
                const targetXPercent = 50 + (balance * 40); // +/- 40% from center
                const currentXPercent = parseFloat(container.style.getPropertyValue('--light-x') || '50');
                const newXPercent = currentXPercent + (targetXPercent - currentXPercent) * 0.1;

                if (!isDragging) {
                    container.style.setProperty('--light-x', `${newXPercent}%`);
                }

                // Debug Output to Screen
                const debugEl = document.getElementById('debug-overlay');
                if (debugEl) {
                    if (frameCount % 10 === 0) {
                        debugEl.innerHTML = `
                            Audio Signal Status:<br>
                            Total Sum: ${sum}<br>
                            Avg Volume: ${avg.toFixed(2)}<br>
                            L: ${stereo.left.toFixed(1)} | R: ${stereo.right.toFixed(1)}<br>
                            Balance: ${balance.toFixed(2)}<br>
                            Intensity: ${intensity.toFixed(2)}
                        `;
                        debugEl.style.color = sum > 0 ? '#0f0' : '#f00';
                    }
                    
                    if (sum > 0) {
                        const borderAlpha = 0.3 + (intensity * 0.7);
                        const glowSize = 5 + (intensity * 20);
                        debugEl.style.border = `2px solid rgba(0, 255, 0, ${borderAlpha})`;
                        debugEl.style.boxShadow = `0 0 ${glowSize}px rgba(0, 255, 0, ${borderAlpha})`;
                    } else {
                        debugEl.style.border = 'none';
                        debugEl.style.boxShadow = 'none';
                    }
                }

                state.updateAudioData(audioData);

                // VISUAL EFFECT: Extreme Color Shift & Spatial Audio
                // Check the store value directly for the render loop logic
                const dynamicLightEnabled = isDynamicLightActive.get();
                
                // Always update CSS vars if light enabled, OR if we need to clear them
                if (container) {
                   const overlay = container.querySelector('.css-light-overlay');
                   
                   if (dynamicLightEnabled) {
                       // 1. Update Overlay Visuals
                       if (overlay) {
                            // Pulse opacity
                            overlay.style.opacity = (0.2 + intensity * 0.8).toFixed(2);
                            
                            // Extreme Color Shift: Blue -> Red
                            const r = Math.floor(intensity * 255);
                            const b = Math.floor((1.0 - intensity) * 255);
                            const g = 0;
                            
                            overlay.style.background = `radial-gradient(
                                circle 1000px at var(--light-x, 50%) var(--light-y, 50%),
                                rgba(${r}, ${g}, ${b}, 0.7) 0%,
                                rgba(${r}, ${g}, ${b}, 0.3) 30%,
                                rgba(0, 0, 0, 0.0) 70%
                            )`;
                       }
                       
                       // 2. Update Global Vars (for Title Shadows, etc.)
                       // Ensure we read the current mouse position from container style if available
                       const lightX = container.style.getPropertyValue('--light-x') || '50%';
                       const lightY = container.style.getPropertyValue('--light-y') || '50%';
                       
                       document.documentElement.style.setProperty('--light-x', lightX);
                       document.documentElement.style.setProperty('--light-y', lightY);
                       document.documentElement.style.setProperty('--light-intensity', intensity.toFixed(2));
                       
                   } else {
                        // Disabled State
                        if (overlay) {
                            overlay.style.opacity = '0';
                        }
                        // We don't remove properties here to avoid "jumping" shadows, just zero intensity?
                        // Or remove them to reset to default CSS fallback?
                        // Let's keep positions but kill intensity for a smooth fade if transition used
                        document.documentElement.style.setProperty('--light-intensity', '0');
                   }
                }
            }
        } catch (audioErr) {
             console.warn("Audio Update Error (Non-fatal):", audioErr);
        }

        state.render();
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- Initialization ---
  async function start() {
    if (!canvas) return;

    try {
      await init();
      state = await startRenderer(canvas);
      
      // 1. Theme Sync
      if (theme) {
        state.setTheme(theme.get() === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) state.setTheme(newValue === 'dark');
        });
      }

      // 1.5 Dynamic Light Sync
      lightUnsub = onSet(isDynamicLightActive, ({ newValue }) => {
         if (!newValue && container) {
             const overlay = container.querySelector('.css-light-overlay');
             if (overlay) overlay.style.opacity = '0';
             document.documentElement.style.removeProperty('--light-x');
             document.documentElement.style.removeProperty('--light-y');
             document.documentElement.style.removeProperty('--light-intensity');
         }
      });

      // 1.6 Model Switching
      let isInitialLoad = true; // Track if we're doing the initial load
      let currentLoadedModel = null; // Track currently loaded model
      
      const loadModel = async (modelType) => {
        // Prevent concurrent loads
        if (isLoadingModel) {
          console.log(`Model load already in progress, skipping ${modelType}`);
          return;
        }

        // Skip if already loaded
        if (currentLoadedModel === modelType && !isInitialLoad) {
          console.log(`Model ${modelType} already loaded, skipping`);
          return;
        }

        // Ensure state is ready
        if (!state) {
          console.error('Cannot load model: renderer state not ready');
          return;
        }

        const modelPath = modelType === 'dark' 
          ? '/models/dezimiertt-glb-03.glb' 
          : '/models/modernart1-sculpt-1.glb';
        
        isLoadingModel = true;
        
        try {
          if (loader) {
            loader.classList.remove('hidden');
            loader.textContent = `LOADING ${modelType.toUpperCase()} MODEL...`;
          }
          
          const response = await fetch(modelPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const bytes = new Uint8Array(await response.arrayBuffer());
          
          // Small delay to ensure renderer is ready (fixes first-click issue)
          if (isInitialLoad) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          state.loadModelFromBytes(bytes);
          
          // Wait a bit for the model to be processed
          await new Promise(resolve => setTimeout(resolve, 50));
          
          currentLoadedModel = modelType; // Track what we loaded
          
          if (loader) {
            loader.classList.add('hidden');
          }
          console.log(`Model switched to: ${modelType}`);
        } catch (e) {
          console.error(`Failed to load model ${modelType}:`, e);
          if (loader) {
            loader.textContent = `ERROR LOADING ${modelType.toUpperCase()}`;
            // Auto-hide error after 3 seconds
            setTimeout(() => {
              if (loader) loader.classList.add('hidden');
            }, 3000);
          }
        } finally {
          isLoadingModel = false;
          if (isInitialLoad) {
            isInitialLoad = false;
          }
        }
      };

      // Load initial model (wait for it to complete before setting up subscription)
      const initialModel = activeModel.get();
      await loadModel(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue, oldValue }) => {
        // Skip if this is the initial value being set or if already loading
        if (isInitialLoad || isLoadingModel) {
          return;
        }
        
        // Only load if state is ready and value actually changed
        if (state && newValue !== oldValue && newValue !== currentLoadedModel) {
          loadModel(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      renderLoop();

    } catch (e) {
      console.group("üî¥ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      if (loader) loader.textContent = "GPU ERROR: " + e; // Zeige Fehler im UI an
      // Ensure we kill any zombie loops
      cleanup(); 
    }
  }

  function triggerResize() {
      // Manuelles Update, respektiert targetDpr
      currentDpr = targetDpr;
      const rect = container.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && width > 0 && height > 0) {
          canvas.width = width;
          canvas.height = height;
          state.resize(width, height);
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-Gr√∂√üen√§nderung (z.B. Fenstergr√∂√üe) immer neu berechnen
      triggerResize();
    });
    resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    container.addEventListener('pointerdown', (e) => {
      console.log("üñ±Ô∏è Pointer Down auf Renderer");
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      
      container.style.cursor = 'grabbing';
      // WICHTIG: Input sperren, damit Drehen auch au√üerhalb des Fensters geht
      container.setPointerCapture(e.pointerId);
    });

    window.addEventListener('pointerup', (e) => {
      isDragging = false;
      container.style.cursor = 'grab';
      if (container.hasPointerCapture(e.pointerId)) {
        container.releasePointerCapture(e.pointerId);
      }
    });

    container.addEventListener('pointermove', (e) => {
      const rect = canvas.getBoundingClientRect();

      if (state && isDragging) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        
        const sensitivity = 1.0;
        state.update_camera(deltaX * sensitivity, deltaY * sensitivity, 0);

        lastX = e.clientX;
        lastY = e.clientY;
      }

      // Shader & CSS Overlay Update
      if (state) {
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Only update dynamic light position if enabled
        if (isDynamicLightActive.get()) {
            state.update(x, y, rect.width, rect.height);
            container.style.setProperty('--light-x', `${e.clientX}px`);
            container.style.setProperty('--light-y', `${e.clientY}px`);
        }
      }
    });

    container.addEventListener('wheel', (e) => {
      if (state) {
        e.preventDefault();
        state.update_camera(0, 0, e.deltaY * 0.5); 
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (lightUnsub) lightUnsub();
    if (modelUnsub) modelUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: #050505;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

.loader {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 2px;
  transition: opacity 0.5s ease;
  pointer-events: none; /* clicks go through */
  z-index: 10;
}
.loader.hidden { opacity: 0; }

.css-light-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none; /* clicks go through */
  opacity: var(--light-opacity, 0);
  transition: opacity 0.1s ease;
  background: radial-gradient(
    circle 800px at var(--light-x, 50%) var(--light-y, 50%),
    rgba(100, 150, 255, 0.6) 0%,
    rgba(50, 80, 200, 0.2) 40%,
    rgba(0, 0, 0, 0.0) 70%
  );
  mix-blend-mode: screen;
  z-index: 2; /* Ensure it's above the canvas */
}
</style>