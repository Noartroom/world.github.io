---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, IMAGE3D-1, dezimiertt-glb-03
const { modelPath = "/models/newmesh.glb" } = Astro.props;
---
<div 
  class="renderer-container" 
  id="renderer-container-id"
  data-canvas-id={CANVAS_ID}
  data-model-path={modelPath}
  aria-label="Interactive 3D Model Viewer" 
  role="application">
  <div 
    id="loader" 
    class="loader"
  >INITIALIZING GPU...</div>

  <!-- Low Power Mode Fallback -->
  <div id="fallback-container" class="fallback-container hidden">
      <img id="fallback-image" src="/models/fallback-light.svg" alt="3D Model Fallback (Low Power Mode)" />
      <div class="fallback-controls">
          <p>Low Power Mode Enabled</p>
          <button id="force-3d-btn" class="force-btn">Enable 3D (High Performance)</button>
      </div>
  </div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
</div>

<script>
  // @ts-ignore
  import init, { startRenderer } from '/pkg/model_renderer.js?v=gpu_fix_6'; /* adjust path for prod/dev */
  import { theme, activeModel, onSet, isBlobActive } from '../lib/stores/sceneStore';
  import { timeStore } from '../lib/stores/timeStore';
  import { deviceState, initDeviceDetection } from '../lib/stores/deviceStore';

  // DOM Elemente
  const container = document.getElementById('renderer-container-id');
  const CANVAS_ID = container?.dataset.canvasId;
  const modelPath = container?.dataset.modelPath;
  // --- Global Scope (f√ºr Cleanup notwendig) ---
  let state: any = null;
  let rafId: number | null = null;
  let resizeObserver: ResizeObserver | null = null;
  let intersectionObserver: IntersectionObserver | null = null;
  let isVisible = true;
  let themeUnsub: (() => void) | null = null;
  let blobUnsub: (() => void) | null = null;
  let modelUnsub: (() => void) | null = null;
  let timeUnsub: (() => void) | null = null;
  let isLoadingModel = false; // Prevent concurrent model loads
  let isFallbackMode = false;

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  let frameTimer = 0;
  let frameCount = 0;
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;

  // DOM Elemente
  const canvas: HTMLCanvasElement | null = CANVAS_ID ? document.getElementById(CANVAS_ID) as HTMLCanvasElement : null;
  const loader = document.getElementById('loader');
  const fallbackContainer = document.getElementById('fallback-container');
  const fallbackImage = document.getElementById('fallback-image') as HTMLImageElement;
  const force3dBtn = document.getElementById('force-3d-btn');

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let isDraggingBlob = false;
  let hasSpawnedSinceActive = false; // Prevents re-spawning on every mouse move
  
  // Multi-touch State (Pinch-to-Zoom)
  const evCache: PointerEvent[] = [];
  let prevDiff = -1;

  // Performance: Cache DOM queries and computed values
  let cachedCanvasRect: DOMRect | null = null;
  let lastCachedRectTime = 0;
  const RECT_CACHE_DURATION = 100; // Cache rect for 100ms

  // --- SOTA Render Loop ---
  function renderLoop(timestamp: number) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas || !canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Monitor Frame Time
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Einfacher FPS Counter √ºber 1 Sekunde
    frameTimer += delta;
    frameCount++;
    
    if (frameTimer >= 1000) {
      const fps = frameCount;
      // console.log(`FPS: ${fps}, DPR: ${currentDpr.toFixed(2)}`);
      
      // Dynamic Resolution Scaling (Tiered)
      // Wenn FPS unter 45 fallen, reduziere Aufl√∂sung (min 0.5)
      if (fps < 45 && currentDpr > 0.5) {
         targetDpr = Math.max(0.5, currentDpr - 0.25);
         triggerResize(); // Trigger resize with new DPR
      }
      // Wenn FPS stabil bei 60 sind, versuche Qualit√§t zu erh√∂hen (bis native DPR)
      else if (fps >= 58 && currentDpr < (window.devicePixelRatio || 1)) {
         targetDpr = Math.min(window.devicePixelRatio || 1, currentDpr + 0.1);
         triggerResize();
      }
      
      frameTimer = 0;
      frameCount = 0;
    }

    if (state) {
      try {

        // --- UI Repulsion (Blob -> UI) ---
        // Get blob position from Rust and push UI elements away
        if (state.getBlobScreenPosition) {
            if (isBlobActive.get()) {
                try {
                    const blobPos = state.getBlobScreenPosition();
                    // Check if we got a valid position (array length 2)
                    if (blobPos && blobPos.length === 2) {
                        const x = blobPos;
                        const y = blobPos;
                        // Only apply if inside screen bounds
                        if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                             // Apply magnetic repulsion to UI elements
                             applyUIRepulsion(x, y);
                        } else {
                             resetUIRepulsion();
                        }
                    }
                } catch (err) {
                    // Ignore transient errors
                }
            } else {
                // Reset if blob is not active
                resetUIRepulsion();
            }
        }

        state.render();
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- UI Repulsion Logic ---
  function applyUIRepulsion(normalizedX: number, normalizedY: number) {
      // Find UI elements to repel (buttons, panels)
      const elements = document.querySelectorAll('.magnetic-ui');
      
      elements.forEach(el => {
          if (!(el instanceof HTMLElement)) return;
          
          const rect = el.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const blobX = normalizedX * window.innerWidth;
          const blobY = normalizedY * window.innerHeight;
          
          const dx = centerX - blobX;
          const dy = centerY - blobY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          const maxDist = 150; // Reduced radius to avoid accidental triggers
          
          if (dist < maxDist) {
              // Calculate repulsion force with smooth easing
              // Power function makes the falloff sharper, so effects only happen when closer
              const intensity = Math.pow(1 - dist / maxDist, 2);
              const force = intensity * 80; // Max 40px push
              const angle = Math.atan2(dy, dx);
              
              const moveX = Math.cos(angle) * force;
              const moveY = Math.sin(angle) * force;
              
              el.style.transform = `translate(${moveX}px, ${moveY}px)`;
          } else {
              el.style.transform = `translate(0px, 0px)`;
          }
      });
  }

  function resetUIRepulsion() {
      const elements = document.querySelectorAll('.magnetic-ui');
      elements.forEach(el => {
          if (el instanceof HTMLElement) {
              el.style.transform = `translate(0px, 0px)`;
          }
      });
  }

  // --- Time-of-Day System ---
  function updateTimeOfDay(currentHour: number) {
      if (!state || !state.setEnvironmentLight) return;
      
      // Calculate normalized time (0.0 - 1.0) based on hours
      // 0.0 = midnight, 0.5 = noon, 1.0 = midnight next day
      const time = currentHour / 24.0;
      
      // SOTA Palette: Strict White/Yellow/Orange as requested
      const moonlight = { r: 0.9, g: 0.95, b: 1.0 };     // White Moonlight (Night) - Clean White
      const moonlight_bright = { r: 1.0, g: 1.0, b: 1.0 }; // Pure White
      const dawn = { r: 1.0, g: 0.6, b: 0.2 };           // Touch of Orange (Sunrise)
      const noon = { r: 1.0, g: 0.95, b: 0.6 };          // Yellow Light (Day)
      const dusk = { r: 1.0, g: 0.5, b: 0.1 };           // Touch of Orange (Sunset)
      
      // Sky Background Colors (Ambient) - Neutralized to avoid purple/magenta
      // Strictly following the palette for ambient as well, but darker
      const sky_night = { r: 0.05, g: 0.05, b: 0.08 };   // Deep Neutral Blue-Black (No Purple)
      const sky_day = { r: 0.5, g: 0.7, b: 0.9 };        // Clear Sky Blue
      const sky_dawn = { r: 0.2, g: 0.15, b: 0.1 };      // Dark Warm Tone

      let light = { r: 0, g: 0, b: 0 };
      let sky = { r: 0, g: 0, b: 0 };
      
      if (time < 0.166) { // 00:00 - 04:00 (Moonlight getting brighter)
          const t = time / 0.166;
          light = lerpColor(moonlight, moonlight_bright, t); // Peak at 4am
          sky = sky_night;
      } else if (time < 0.25) { // 04:00 - 06:00 (Brightest Moon -> Dawn)
          const t = (time - 0.166) / 0.084;
          light = lerpColor(moonlight_bright, dawn, t);
          sky = lerpColor(sky_night, sky_dawn, t);
      } else if (time < 0.5) { // 06:00 - 12:00 (Dawn -> Noon)
          const t = (time - 0.25) / 0.25;
          light = lerpColor(dawn, noon, t);
          sky = lerpColor(sky_dawn, sky_day, t);
      } else if (time < 0.75) { // 12:00 - 18:00 (Noon -> Sunset)
          const t = (time - 0.5) / 0.25;
          light = lerpColor(noon, dusk, t);
          sky = lerpColor(sky_day, sky_dawn, t);
      } else { // 18:00 - 24:00 (Sunset -> Moonlight)
          const t = (time - 0.75) / 0.25;
          light = lerpColor(dusk, moonlight, t);
          sky = lerpColor(sky_dawn, sky_night, t);
      }
      
      state.setEnvironmentLight(
          sky.r, sky.g, sky.b,
          light.r, light.g, light.b
      );
  }
  
  function lerpColor(c1: any, c2: any, t: number) {
      return {
          r: c1.r + (c2.r - c1.r) * t,
          g: c1.g + (c2.g - c1.g) * t,
          b: c1.b + (c2.b - c1.b) * t
      };
  }

  // --- Initialization ---
  async function start(forceHighPerformance = false) {
    if (!canvas) return;

    // Detect Device Capabilities
    initDeviceDetection();
    const device = deviceState.get();

    // Check if we should use fallback
    if (!forceHighPerformance && (device.isLowPower || !device.hasWebGPU)) {
      activateFallbackMode();
      return;
    }

    // Initialize 3D Renderer
    try {
      if (loader) loader.classList.remove('hidden');
      await init();
      const isMobile = window.innerWidth < 768;
      state = await startRenderer(canvas, isMobile);
      
      // Hide fallback if it was visible
      if (fallbackContainer) fallbackContainer.classList.add('hidden');
      if (canvas) canvas.style.display = 'block';
      
      // 1. Theme Sync - Initialize lighting based on current theme
      if (theme) {
        const initialTheme = theme.get();
        state.setTheme(initialTheme === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) {
                state.setTheme(newValue === 'dark');
                // Fix: Re-apply time-of-day lighting immediately to prevent theme defaults from overriding it
                // Firefox Fix: Defer execution to ensure setTheme has fully processed
                requestAnimationFrame(() => {
                    updateTimeOfDay(timeStore.get());
                });
            }
        });
      }
      
      // 1.1 Time-of-Day Sync
      timeUnsub = timeStore.subscribe((value: number) => {
         updateTimeOfDay(value);
      });

      // Handle light blob spawning/despawning ONLY (separate from CSS lighting)
      blobUnsub = onSet(isBlobActive, ({ newValue }) => {
         if (!newValue && state?.despawnBlob) {
             state.despawnBlob();
             isDraggingBlob = false;
             hasSpawnedSinceActive = false; // Reset the flag so it can be spawned again if re-enabled
         }
      });

      // Initialize Blob State (Ensure it syncs with store, especially if default is false)
      if (state && state.despawnBlob && !isBlobActive.get()) {
          state.despawnBlob();
      }

      // 1.6 Model Switching
      let isInitialLoad = true; // Track if we're doing the initial load
      let currentLoadedModel: string | null = null; // Track currently loaded model
      
      const loadModel = async (modelType: string) => {
        // Prevent concurrent loads
        if (isLoadingModel) {
          console.log(`Model load already in progress, skipping ${modelType}`);
          return;
        }

        // Skip if already loaded
        if (currentLoadedModel === modelType && !isInitialLoad) {
          console.log(`Model ${modelType} already loaded, skipping`);
          return;
        }

        // Ensure state is ready
        if (!state) {
          console.error('Cannot load model: renderer state not ready');
          return;
        }

        const modelPath = modelType === 'dark'
          ? '/models/dezimiertt-glb-03.glb'
          : '/models/newmesh.glb';
        
        isLoadingModel = true;
        
        try {
          if (loader) {
            loader.classList.remove('hidden');
            loader.textContent = `LOADING ${modelType.toUpperCase()} MODEL...`;
          }
          
          const response = await fetch(modelPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const bytes = new Uint8Array(await response.arrayBuffer());
          
          // Small delay to ensure renderer is ready (fixes first-click issue)
          if (isInitialLoad) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          state.loadModelFromBytes(bytes);
          
          // Wait a bit for the model to be processed
          await new Promise(resolve => setTimeout(resolve, 50));
          
          currentLoadedModel = modelType; // Track what we loaded
          
          if (loader) {
            loader.classList.add('hidden');
          }
          console.log(`Model switched to: ${modelType}`);
        } catch (e) {
          console.error(`Failed to load model ${modelType}:`, e);
          // If the model fails (e.g. offline), FORCE the fallback UI to appear
          if (isInitialLoad) {
            console.log('Offline or Load Error: Activating Fallback Mode');
            activateFallbackMode(); 
          }
          if (loader) {
            loader.textContent = `OFFLINE / ERROR`; // Update text to be clear
            // Auto-hide error after 3 seconds
            setTimeout(() => {
              if (loader) loader.classList.add('hidden');
            }, 3000);
          }
        } finally {
          isLoadingModel = false;
          if (isInitialLoad) {
            isInitialLoad = false;
          }
        }
      };

      // Load initial model (wait for it to complete before setting up subscription)
      const initialModel = activeModel.get();
      await loadModel(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue }) => {
        // Skip if this is the initial value being set or if already loading
        if (isInitialLoad || isLoadingModel) {
          return;
        }
        
        // Only load if state is ready and value actually changed
        if (state && newValue !== currentLoadedModel) {
          loadModel(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      rafId = requestAnimationFrame(renderLoop);

    } catch (e: any) {
      console.group("üî¥ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      // If WebGPU init fails, fall back!
      activateFallbackMode();
      
      if (loader) loader.textContent = "GPU ERROR: " + e; // Zeige Fehler im UI an
      // Ensure we kill any zombie loops
      cleanup();
    }
  }

  function activateFallbackMode() {
      isFallbackMode = true;
      if (loader) loader.classList.add('hidden');
      if (canvas) canvas.style.display = 'none';
      if (fallbackContainer) fallbackContainer.classList.remove('hidden');

      // Sync Fallback Theme
      themeUnsub = onSet(activeModel, ({ newValue }) => {
          updateFallbackImage(newValue);
      });
      updateFallbackImage(activeModel.get());
  }

  function updateFallbackImage(currentModel: string) {
      if (fallbackImage) {
          fallbackImage.src = currentModel === 'dark'
              ? '/models/fallback-dark.svg'
              : '/models/fallback-light.svg';
      }
  }

  if (force3dBtn) {
      force3dBtn.addEventListener('click', () => {
          start(true);
      });
  }

  function triggerResize() {
      if (!container || !canvas) return;
      // Manuelles Update, respektiert targetDpr
      currentDpr = targetDpr;
      const rect = container.getBoundingClientRect();
      // Invalidate cached canvas rect when resizing
      cachedCanvasRect = null;
      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && canvas && width > 0 && height > 0) {
          canvas.width = width;
          canvas.height = height;
          state.resize(width, height);
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-Gr√∂√üen√§nderung (z.B. Fenstergr√∂√üe) immer neu berechnen
      triggerResize();
    });
    if (container) resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    if (canvas) intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    if (!container || !canvas) return;

    container.addEventListener('pointerdown', (e: PointerEvent) => {
      if (!state) return;

      evCache.push(e);

      // If multi-touch, skip dragging logic (handled in pointermove)
      if (evCache.length > 1) {
          isDragging = false;
          return;
      }

      const blobActive = isBlobActive.get();
      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Priority: 1. Start dragging blob
      if (blobActive && state.startDragBlob && state.startDragBlob(x, y, rect.width, rect.height)) {
        isDraggingBlob = true;
        isDragging = false; // Prevent camera drag
        e.preventDefault();
        e.stopPropagation();
        container.setPointerCapture(e.pointerId);
        container.style.cursor = 'grabbing';
      }
      // Priority: 2. Start dragging camera
      else {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        container.style.cursor = 'grabbing';
        container.setPointerCapture(e.pointerId);
      }
    });

    const handlePointerUp = (e: PointerEvent) => {
      // Remove from cache
      const index = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
      if (index > -1) {
          evCache.splice(index, 1);
      }
      
      // Reset pinch state
      if (evCache.length < 2) {
          prevDiff = -1;
      }

      // Re-anchor if going from 2 -> 1 touches
      if (evCache.length === 1) {
          lastX = evCache[0].clientX;
          lastY = evCache[0].clientY;
          // Resume dragging only if we were not dragging blob
          if (!isDraggingBlob) {
              isDragging = true;
          }
      }

      if (isDraggingBlob && state && state.stopDragBlob) {
        state.stopDragBlob();
        isDraggingBlob = false;
      }
      
      if (evCache.length === 0) {
          isDragging = false;
          if (container) {
            container.style.cursor = 'grab';
            if (container.hasPointerCapture(e.pointerId)) {
              container.releasePointerCapture(e.pointerId);
            }
          }
      }
    };

    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointercancel', handlePointerUp);
    window.addEventListener('pointerleave', handlePointerUp);

    container.addEventListener('pointermove', (e: PointerEvent) => {
      if (!state || !canvas) return;

      // Update cache
      const index = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
      if (index > -1) {
          evCache[index] = e;
      }

      // Multi-touch Pinch-to-Zoom
      if (evCache.length === 2) {
          const dx = evCache[1].clientX - evCache[0].clientX;
          const dy = evCache[1].clientY - evCache[0].clientY;
          const curDiff = Math.hypot(dx, dy);

          if (prevDiff > 0) {
              const delta = prevDiff - curDiff;
              // Zoom sensitivity: positive delta = pinch in (zoom out) -> increase radius
              state.update_camera(0, 0, delta * 3.0);
          }
          prevDiff = curDiff;
          
          // Reset drag state during zoom
          isDragging = false;
          return;
      }

      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;

      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // SOTA: Spawn blob on first mouse move to prevent initial position glitch
      if (isBlobActive.get() && !hasSpawnedSinceActive && state.spawnBlob) {
        state.spawnBlob(x, y, rect.width, rect.height);
        hasSpawnedSinceActive = true;
      }

      if (isDragging && !isDraggingBlob) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        state.update_camera(deltaX * 1.0, deltaY * 1.0, 0);
        lastX = e.clientX;
        lastY = e.clientY;
      }


      if (isDraggingBlob) {
        state.update(x, y, rect.width, rect.height);
      }

      if (isBlobActive.get() && !isDraggingBlob && !isDragging) {
        if (state.isHoveringBlob && state.isHoveringBlob(x, y, rect.width, rect.height)) {
          container.style.cursor = 'grab';
        } else {
          container.style.cursor = 'default';
        }
      } else if (isDraggingBlob) {
        container.style.cursor = 'grabbing';
      }
    });

    container.addEventListener('wheel', (e: WheelEvent) => {
      if (state) {
        e.preventDefault();
        if (isBlobActive.get() && isDraggingBlob && state.updateBlobY) {
          state.updateBlobY(e.deltaY);
        } else {
          state.update_camera(0, 0, e.deltaY * 0.5);
        }
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (blobUnsub) blobUnsub();
    if (timeUnsub) timeUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: transparent;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

.loader {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 2px;
  transition: opacity 0.5s ease;
  pointer-events: none; /* clicks go through */
  z-index: 10;
}
.loader.hidden { opacity: 0; }

.time-display {
  position: absolute;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Courier New', monospace; /* Tech/Digital feel */
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: 0.1rem;
  z-index: 10; /* Above canvas */
  pointer-events: none;
  transition: color 1s ease, text-shadow 1s ease;
}

.fallback-container {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: transparent;
    z-index: 5;
}

.fallback-container.hidden {
    display: none;
}

#fallback-image {
    width: 60%;
    height: auto;
    max-width: 600px;
    opacity: 0.8;
}

.fallback-controls {
    margin-top: 2rem;
    text-align: center;
}

.force-btn {
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.4);
    color: inherit;
    border-radius: 8px;
    backdrop-filter: blur(10px);
    cursor: pointer;
    transition: all 0.2s;
}

.force-btn:hover {
    background: rgba(255, 255, 255, 0.4);
    transform: scale(1.05);
}
</style>

