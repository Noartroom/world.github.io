---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, newmesh, dezimiertt-glb-03 (too big), PORTAL
const { modelPath = "/models/newmesh.glb" } = Astro.props;
---
<div 
  class="renderer-container" 
  id="renderer-container-id"
  data-canvas-id={CANVAS_ID}
  data-model-path={modelPath}
  aria-label="Interactive 3D Model Viewer" 
  role="application">
  
  <!-- Low Power Mode Fallback -->
  <div id="fallback-container" class="fallback-container hidden">
      <div class="fallback-controls">
          <p>Low Power Mode Enabled</p>
          <button id="force-3d-btn" class="force-btn">Enable 3D (High Performance)</button>
      </div>
  </div>
  
  <div id="loader" class="loader hidden" role="status" aria-live="polite">
    LOADING 3D...
  </div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
</div>

<script>
  // @ts-ignore
  import init, { startRenderer } from '/pkg/model_renderer.js'; /* adjust path for prod/dev */
  import { theme, activeModel, onSet, isBlobActive, activeLayer } from '../lib/stores/sceneStore';
  import { timeStore } from '../lib/stores/timeStore';
  import { deviceState, initDeviceDetection } from '../lib/stores/deviceStore';

  // DOM Elemente
  const container = document.getElementById('renderer-container-id');
  const CANVAS_ID = container?.dataset.canvasId;
  const modelPath = container?.dataset.modelPath;
  const loader = document.getElementById('loader');
  const BASE_MODEL_PATH = '/models/PORTAL2.glb';
  const SOTA_MODEL_PATH = '/models/newmesh.glb';
  // --- Global Scope (fÃ¼r Cleanup notwendig) ---
  let state: any = null;
  let rafId: number | null = null;
  let resizeObserver: ResizeObserver | null = null;
  let intersectionObserver: IntersectionObserver | null = null;
  let isVisible = true;
  let themeUnsub: (() => void) | null = null;
  let blobUnsub: (() => void) | null = null;
  let modelUnsub: (() => void) | null = null;
  let timeUnsub: (() => void) | null = null;
  let layerUnsub: (() => void) | null = null;
  let isLoadingModel = false; // Prevent concurrent model loads
  let currentLoadedModelPath: string | null = null; // Track last loaded asset
  let isInitialLoad = true;
  let isFallbackMode = false;

  // UI Repulsion Cache
  let uiCache: any[] = [];
  let isTransitioning = false;

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  const HISTORY_SIZE = 12;
  let fpsHistory: number[] = [];
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;
  const DRS_STEP = 0.1;
  const DRS_COOLDOWN_MS = 600;
  let lastDrsAdjust = 0;
  let lastWidth = 0;
  let lastHeight = 0;

  // DOM Elemente
  const canvas: HTMLCanvasElement | null = CANVAS_ID ? document.getElementById(CANVAS_ID) as HTMLCanvasElement : null;
  const fallbackContainer = document.getElementById('fallback-container');
  const force3dBtn = document.getElementById('force-3d-btn');
  const DEFAULT_LOADER_TEXT = 'LOADING 3D...';
  const ua = navigator.userAgent || '';
  const isIOS = /iPhone|iPad|iPod/i.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  let altRendererCache: { init: () => Promise<any>; startRenderer: (canvas: HTMLCanvasElement, isMobile: boolean) => Promise<any> } | null = null;
  let useAltRenderer = false;
  let altLoadError: any = null;

  async function loadAltRenderer() {
    if (altRendererCache) return altRendererCache;
    try {
      // Lazy-load GL-only bundle; resilient to different export names
      // @ts-ignore dynamic alt bundle
      const mod: any = await import(/* @vite-ignore */ '/pkg/model_renderer_gl.js');
      const altInit = mod?.default || mod?.init || mod?.initGL;
      const altStart = mod?.startRendererGL || mod?.startRenderer;
      if (!altInit || !altStart) {
        throw new Error('Alt renderer exports not found');
      }
      altRendererCache = {
        init: () => altInit(),
        startRenderer: (c: HTMLCanvasElement, isMobile: boolean) => altStart(c, isMobile)
      };
      return altRendererCache;
    } catch (e) {
      altLoadError = e;
      throw e;
    }
  }

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let isDraggingBlob = false;
  let hasSpawnedSinceActive = false; // Prevents re-spawning on every mouse move
  
  // Multi-touch State (Pinch-to-Zoom)
  const evCache: PointerEvent[] = [];
  let prevDiff = -1;

  // Performance: Cache DOM queries and computed values
  let cachedCanvasRect: DOMRect | null = null;
  let lastCachedRectTime = 0;
  const RECT_CACHE_DURATION = 100; // Cache rect for 100ms

  // --- SOTA Render Loop ---
  function renderLoop(timestamp: number) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas || !canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Rolling FPS
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    const instantFps = delta > 0 ? 1000 / delta : 60;
    fpsHistory.push(instantFps);
    if (fpsHistory.length > HISTORY_SIZE) fpsHistory.shift();
    const avgFps = fpsHistory.reduce((sum, v) => sum + v, 0) / fpsHistory.length;

    const canAdjustDrs = (timestamp - lastDrsAdjust) >= DRS_COOLDOWN_MS && !isTransitioning;
    if (canAdjustDrs) {
      const nativeCap = window.devicePixelRatio || 1;
      if (avgFps < 45 && targetDpr > 0.5) {
        targetDpr = Math.max(0.5, targetDpr - DRS_STEP);
        triggerResize();
        lastDrsAdjust = timestamp;
      } else if (avgFps > 55 && targetDpr < nativeCap) {
        targetDpr = Math.min(nativeCap, targetDpr + DRS_STEP);
        triggerResize();
        lastDrsAdjust = timestamp;
      }
    }

    if (state) {
      try {

        // --- UI Repulsion (Blob -> UI) ---
        // Get blob position from Rust and push UI elements away
        if (state.getBlobScreenX && state.getBlobScreenY) {
            if (isBlobActive.get()) {
                const x = state.getBlobScreenX();
                const y = state.getBlobScreenY();
                if (Number.isFinite(x) && Number.isFinite(y) && x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                    applyUIRepulsion(x, y);
                } else {
                    resetUIRepulsion();
                }
            } else {
                resetUIRepulsion();
            }
        }
        
        // Pass time in seconds for shader animations
        state.render(timestamp * 0.001);
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- UI Repulsion Logic (Optimized) ---
  // READ: Only access DOM on resize or specific triggers
  function updateUICache() {
    const elements = document.querySelectorAll('.magnetic-ui');
    uiCache = Array.from(elements).map(el => {
      const rect = el.getBoundingClientRect();
      return {
        el: el as HTMLElement,
        // Store center point relative to viewport
        cx: rect.left + rect.width / 2,
        cy: rect.top + rect.height / 2
      };
    });
  }

  // WRITE: Runs at 60FPS (Pure Math + GPU Transform)
  function applyUIRepulsion(normalizedX: number, normalizedY: number) {
      if (uiCache.length === 0) return;

      const blobX = normalizedX * window.innerWidth;
      const blobY = normalizedY * window.innerHeight;
      const maxDist = 150;
      const maxDistSq = maxDist * maxDist; // Optimization: Avoid Math.sqrt

      for (let i = 0; i < uiCache.length; i++) {
          const item = uiCache[i];
          const dx = item.cx - blobX;
          const dy = item.cy - blobY;
          const distSq = dx*dx + dy*dy;

          if (distSq < maxDistSq) {
              // Normalize distance (0 to 1)
              const t = 1 - (distSq / maxDistSq);
              // Smooth falloff (Quadratic)
              const intensity = t * t;
              
              const force = intensity * 80;
              const angle = Math.atan2(dy, dx);
              
              // USE TRANSLATE3D: Promotes element to compositor layer
              item.el.style.transform = `translate3d(${Math.cos(angle) * force}px, ${Math.sin(angle) * force}px, 0)`;
          } else {
               // Clean up style if needed, but avoid layout reads
               // Check existing transform string directly to avoid computed style read
               if (item.el.style.transform) {
                   item.el.style.transform = '';
               }
          }
      }
  }

  function resetUIRepulsion() {
      // Use cache for reset too
      for (let i = 0; i < uiCache.length; i++) {
         const item = uiCache[i];
         if (item.el.style.transform) {
             item.el.style.transform = '';
         }
      }
  }

  // --- Time-of-Day System ---
  function updateTimeOfDay(currentHour: number) {
      if (!state || !state.setEnvironmentLight) return;
      
      // Calculate normalized time (0.0 - 1.0) based on hours
      // 0.0 = midnight, 0.5 = noon, 1.0 = midnight next day
      const time = currentHour / 24.0;
      
      // SOTA Palette: Strict White/Yellow/Orange as requested
      const moonlight = { r: 0.9, g: 0.95, b: 1.0 };     // White Moonlight (Night) - Clean White
      const moonlight_bright = { r: 1.0, g: 1.0, b: 1.0 }; // Pure White
      const dawn = { r: 1.0, g: 0.6, b: 0.2 };           // Touch of Orange (Sunrise)
      const noon = { r: 1.0, g: 0.95, b: 0.6 };          // Yellow Light (Day)
      const dusk = { r: 1.0, g: 0.5, b: 0.1 };           // Touch of Orange (Sunset)
      
      // Sky Background Colors (Ambient) - Neutralized to avoid purple/magenta
      // Strictly following the palette for ambient as well, but darker
      const sky_night = { r: 0.05, g: 0.05, b: 0.08 };   // Deep Neutral Blue-Black (No Purple)
      const sky_day = { r: 0.5, g: 0.7, b: 0.9 };        // Clear Sky Blue
      const sky_dawn = { r: 0.2, g: 0.15, b: 0.1 };      // Dark Warm Tone

      let light = { r: 0, g: 0, b: 0 };
      let sky = { r: 0, g: 0, b: 0 };
      
      if (time < 0.166) { // 00:00 - 04:00 (Moonlight getting brighter)
          const t = time / 0.166;
          light = lerpColor(moonlight, moonlight_bright, t); // Peak at 4am
          sky = sky_night;
      } else if (time < 0.25) { // 04:00 - 06:00 (Brightest Moon -> Dawn)
          const t = (time - 0.166) / 0.084;
          light = lerpColor(moonlight_bright, dawn, t);
          sky = lerpColor(sky_night, sky_dawn, t);
      } else if (time < 0.5) { // 06:00 - 12:00 (Dawn -> Noon)
          const t = (time - 0.25) / 0.25;
          light = lerpColor(dawn, noon, t);
          sky = lerpColor(sky_dawn, sky_day, t);
      } else if (time < 0.75) { // 12:00 - 18:00 (Noon -> Sunset)
          const t = (time - 0.5) / 0.25;
          light = lerpColor(noon, dusk, t);
          sky = lerpColor(sky_day, sky_dawn, t);
      } else { // 18:00 - 24:00 (Sunset -> Moonlight)
          const t = (time - 0.75) / 0.25;
          light = lerpColor(dusk, moonlight, t);
          sky = lerpColor(sky_dawn, sky_night, t);
      }
      
      state.setEnvironmentLight(
          sky.r, sky.g, sky.b,
          light.r, light.g, light.b
      );
  }
  
  function lerpColor(c1: any, c2: any, t: number) {
      return {
          r: c1.r + (c2.r - c1.r) * t,
          g: c1.g + (c2.g - c1.g) * t,
          b: c1.b + (c2.b - c1.b) * t
      };
  }

  function getModelPathForType(modelType: string) {
    if (modelType === 'dark') {
      return '/models/PORTAL2.glb';
    }
    return modelPath || '/models/newmesh.glb';
  }

  async function probeWebGPUAdapter(timeoutMs = 400) {
    // Fast probe to detect blocked/denied adapters on browsers that still expose navigator.gpu
    // Returns true if an adapter is obtainable within timeout.
    // If navigator.gpu is absent this will return false (handled by device tier logic).
    // eslint-disable-next-line compat/compat
    if (!navigator.gpu) return false;
    try {
      const adapterPromise = navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
      const timeoutPromise = new Promise(resolve => setTimeout(() => resolve(null), timeoutMs));
      const adapter = await Promise.race([adapterPromise, timeoutPromise]);
      return !!adapter;
    } catch (e) {
      console.warn('WebGPU adapter probe failed, falling back if possible.', e);
      return false;
    }
  }

  async function fetchAndLoadModel(
    path: string,
    options: { label?: string; skipIfLoaded?: boolean; onFailure?: () => Promise<void> | void } = {}
  ) {
    const { label, skipIfLoaded = true, onFailure } = options;
    if (!state) {
      console.error('Cannot load model: renderer state not ready');
      return;
    }

    if (skipIfLoaded && currentLoadedModelPath === path) {
      console.log(`Model ${label || path} already loaded, skipping`);
      return;
    }

    if (isLoadingModel) {
      console.log(`Model load already in progress, skipping ${label || path}`);
      return;
    }

    isLoadingModel = true;
    try {
      const response = await fetch(path);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const bytes = new Uint8Array(await response.arrayBuffer());
      state.loadModelFromBytes(bytes);
      currentLoadedModelPath = path;
    } catch (e) {
      console.error(`Failed to load model${label ? ` (${label})` : ''}:`, e);
      if (onFailure) {
        await onFailure();
      } else if (isInitialLoad) {
        activateFallbackMode();
      }
    } finally {
      isLoadingModel = false;
    }
  }

  async function loadBalancedModel() {
    const preferredPath = BASE_MODEL_PATH;
    await fetchAndLoadModel(preferredPath, {
      label: 'base',
      skipIfLoaded: false,
      onFailure: async () => {
        const fallbackPath = getModelPathForType(activeModel.get());
        if (fallbackPath !== preferredPath) {
          await fetchAndLoadModel(fallbackPath, { label: 'base-fallback', skipIfLoaded: false });
        } else {
          activateFallbackMode();
        }
      }
    });
    if (!isFallbackMode) {
      isInitialLoad = false;
    }
  }

  async function loadModelByTheme(modelType: string) {
    const path = getModelPathForType(modelType);
    await fetchAndLoadModel(path, { label: `theme:${modelType}` });
  }

  async function triggerSotaUpgrade() {
    const device = deviceState.get();
    if (device.networkTier === 'low') return;

    console.log('ðŸš€ Triggering SOTA Asset Upgrade...');
    
    if (loader) {
      loader.textContent = 'UPGRADING TEXTURES...';
      loader.classList.remove('hidden');
    }

    try {
      const response = await fetch(SOTA_MODEL_PATH);
      if (!response.ok) throw new Error('Download failed');
      
      const bytes = new Uint8Array(await response.arrayBuffer());

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (state) {
            state.loadModelFromBytes(bytes);
            currentLoadedModelPath = SOTA_MODEL_PATH;
            console.log('âœ¨ Visuals upgraded to SOTA');
          }
          if (loader) {
            loader.textContent = DEFAULT_LOADER_TEXT;
            loader.classList.add('hidden');
          }
        });
      });
    } catch (e) {
      console.warn('SOTA upgrade failed, staying on Base model.', e);
      if (loader) {
        loader.textContent = DEFAULT_LOADER_TEXT;
        loader.classList.add('hidden');
      }
    }
  }

  // --- Initialization ---
  async function start(forceHighPerformance = false) {
    if (!canvas) return;

    if (loader) {
      loader.textContent = DEFAULT_LOADER_TEXT;
      loader.classList.remove('hidden');
    }

    await initDeviceDetection();
    let device = deviceState.get();

    // Debug flags
    const params = new URLSearchParams(window.location.search);
    const forceFallback = params.get('fallback') === '1';
    const enableGL = params.get('enableGL') === '1';
    const forceAltRenderer = params.get('altgl') === '1';

    if (forceFallback) {
      console.warn('Fallback mode forced via query param.');
      activateFallbackMode();
      if (loader) loader.classList.add('hidden');
      return;
    }

    // Optional Chrome flag: force WebGL-only path (query ?webgl=1 or localStorage "webglOnly" === "true")
    const forceWebGLOnly = params.get('webgl') === '1' || localStorage.getItem('webglOnly') === 'true';
    if (forceWebGLOnly && device.hasWebGL) {
      deviceState.set({
        ...device,
        hasWebGPU: false,
        tier: 'balanced',
        isLowPower: false
      });
      device = deviceState.get();
      console.warn('WebGL-only mode enabled (Chrome flag). WebGPU disabled for this session.');
    }

    // Fast WebGPU adapter probe to catch blocked/denied adapters on Chrome variants
    const adapterAvailable = await probeWebGPUAdapter();
    if (device.hasWebGPU && !adapterAvailable) {
      // Downgrade to WebGL tier if available; otherwise fallback tier
      deviceState.set({
        ...device,
        hasWebGPU: false,
        tier: device.hasWebGL ? 'balanced' : 'low',
        isLowPower: !device.hasWebGL
      });
      device = deviceState.get();
    }

    // Preflight WebGL2 context to avoid wgpu "No adapter" when GL is blocked
    if (!device.hasWebGPU) {
      const glCanvas = document.createElement('canvas');
      const gl = glCanvas.getContext('webgl2', { antialias: true, premultipliedAlpha: false });
      if (!gl) {
        console.warn('WebGL2 unavailable; activating fallback.');
        activateFallbackMode();
        if (loader) loader.classList.add('hidden');
        return;
      }
    }

    // iOS Safari: if WebGPU is absent/blocked, only attempt GL when explicitly enabled
    if (!forceHighPerformance && isIOS && !device.hasWebGPU && !enableGL) {
      console.warn('iOS Safari without WebGPU: using fallback (enable with ?enableGL=1 to force GL).');
      activateFallbackMode();
      if (loader) loader.classList.add('hidden');
      return;
    }

    // Check if we should use fallback
    if (!forceHighPerformance && device.tier === 'low') {
      activateFallbackMode();
      if (loader) loader.classList.add('hidden');
      return;
    }

    // Initialize 3D Renderer
    let initFn: () => Promise<any> = init;
    let startFn: (canvas: HTMLCanvasElement, isMobile: boolean) => Promise<any> = startRenderer;

    if (forceAltRenderer) {
      try {
        const alt = await loadAltRenderer();
        initFn = alt.init;
        startFn = alt.startRenderer;
        useAltRenderer = true;
        console.warn('Using alternate GL renderer (forced by altgl flag).');
      } catch (e) {
        console.warn('Failed to load alternate GL renderer (altgl flag). Falling back to primary.', e);
      }
    }

    try {
      await initFn();
      state = await startFn(canvas, device.isMobile);
      
      // REMOVED: Fallback hiding moved to after model load
      // if (fallbackContainer) fallbackContainer.classList.add('hidden');
      
      if (canvas) canvas.style.display = 'block';

      // Load balanced-tier model first for faster TTI
      await loadBalancedModel();
      if (isFallbackMode) {
        if (loader) loader.classList.add('hidden');
        return;
      }
      
      if (loader) loader.classList.add('hidden');
      
      // Hide fallback after balanced/base model is ready
      if (fallbackContainer) {
          fallbackContainer.classList.add('hidden');
      }
      if (document?.body) {
          document.body.classList.remove('fallback-mode');
      }

      if (device.tier === 'ultra' && device.networkTier === 'high') {
        console.log('â³ Tier Ultra detected. Scheduling SOTA upgrade...');
        setTimeout(() => triggerSotaUpgrade(), 2000);
      }
      
      // 1. Theme Sync - Initialize lighting based on current theme
      if (theme) {
        const initialTheme = theme.get();
        state.setTheme(initialTheme === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) {
                state.setTheme(newValue === 'dark');
                // Fix: Re-apply time-of-day lighting immediately to prevent theme defaults from overriding it
                // Firefox Fix: Defer execution to ensure setTheme has fully processed
                requestAnimationFrame(() => {
                    updateTimeOfDay(timeStore.get());
                });
            }
        });
      }
      
      // 1.1 Time-of-Day Sync
      timeUnsub = timeStore.subscribe((value: number) => {
         updateTimeOfDay(value);
      });

      // 1.2 Layer Switch Monitor (Quality Control)
      layerUnsub = activeLayer.subscribe(() => {
          isTransitioning = true;
          // Lock DRS for 600ms (duration of CSS transition)
          setTimeout(() => {
              isTransitioning = false;
          }, 600);
      });

      // Handle light blob spawning/despawning ONLY (separate from CSS lighting)
      blobUnsub = onSet(isBlobActive, ({ newValue }) => {
         if (!newValue && state?.despawnBlob) {
             state.despawnBlob();
             isDraggingBlob = false;
             hasSpawnedSinceActive = false; // Reset the flag so it can be spawned again if re-enabled
         }
         // Spawn immediately when toggled ON (all devices)
         else if (newValue && state?.spawnBlob && !hasSpawnedSinceActive) {
             if (canvas) {
                 const rect = canvas.getBoundingClientRect();
                 // Spawn near center but slightly offset to avoid blocking view too much
                 // Position at ~60% width and ~55% height for a natural, non-intrusive placement
                 const spawnX = rect.width * 0.6;
                 const spawnY = rect.height * 0.55;
                 state.spawnBlob(spawnX, spawnY, rect.width, rect.height);
                 hasSpawnedSinceActive = true;
             }
         }
      });

      // Initialize Blob State (Ensure it syncs with store, especially if default is false)
      if (state && state.despawnBlob && !isBlobActive.get()) {
          state.despawnBlob();
      }

      // 1.6 Model Switching
      const initialModel = activeModel.get();
      await loadModelByTheme(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue }) => {
        if (isLoadingModel) {
          return;
        }
        
        if (state && newValue) {
          loadModelByTheme(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      // Initial UI Cache calculation
      setTimeout(updateUICache, 100);

      rafId = requestAnimationFrame(renderLoop);

    } catch (e: any) {
      // Retry once with alternate renderer if not already using it
      if (!useAltRenderer) {
        try {
          const alt = await loadAltRenderer();
          await alt.init();
          state = await alt.startRenderer(canvas, device.isMobile);
          useAltRenderer = true;
          if (canvas) canvas.style.display = 'block';

          await loadBalancedModel();
          if (isFallbackMode) {
            if (loader) loader.classList.add('hidden');
            return;
          }
          if (loader) loader.classList.add('hidden');
          if (fallbackContainer) fallbackContainer.classList.add('hidden');
          if (document?.body) document.body.classList.remove('fallback-mode');
          if (device.tier === 'ultra' && device.networkTier === 'high') {
            setTimeout(() => triggerSotaUpgrade(), 2000);
          }

          if (theme) {
            const initialTheme = theme.get();
            state.setTheme(initialTheme === 'dark');
            themeUnsub = onSet(theme, ({ newValue }) => {
              if (state) {
                state.setTheme(newValue === 'dark');
                requestAnimationFrame(() => {
                  updateTimeOfDay(timeStore.get());
                });
              }
            });
          }
          timeUnsub = timeStore.subscribe((value: number) => {
            updateTimeOfDay(value);
          });
          layerUnsub = activeLayer.subscribe(() => {
            isTransitioning = true;
            setTimeout(() => {
              isTransitioning = false;
            }, 600);
          });
          blobUnsub = onSet(isBlobActive, ({ newValue }) => {
            if (!newValue && state?.despawnBlob) {
              state.despawnBlob();
              isDraggingBlob = false;
              hasSpawnedSinceActive = false;
            } else if (newValue && state?.spawnBlob && !hasSpawnedSinceActive) {
              if (canvas) {
                const rect = canvas.getBoundingClientRect();
                // Spawn near center but slightly offset to avoid blocking view too much
                // Position at ~60% width and ~55% height for a natural, non-intrusive placement
                const spawnX = rect.width * 0.6;
                const spawnY = rect.height * 0.55;
                state.spawnBlob(spawnX, spawnY, rect.width, rect.height);
                hasSpawnedSinceActive = true;
              }
            }
          });
          if (state && state.despawnBlob && !isBlobActive.get()) {
            state.despawnBlob();
          }
          const initialModel = activeModel.get();
          await loadModelByTheme(initialModel);
          modelUnsub = onSet(activeModel, ({ newValue }) => {
            if (isLoadingModel) return;
            if (state && newValue) {
              loadModelByTheme(newValue);
            }
          });
          setupObservers();
          setupInput();
          triggerInitialResize();
          setTimeout(updateUICache, 100);
          rafId = requestAnimationFrame(renderLoop);
          return;
        } catch (altErr) {
          console.warn('Alternate renderer failed:', altErr);
        }
      }

      console.group("ðŸ”´ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      activateFallbackMode();
      if (loader) loader.classList.add('hidden');
      console.warn('Falling back due to renderer init failure:', e?.message || e);
      
      cleanup();
    }
  }

  function activateFallbackMode() {
      isFallbackMode = true;
      if (canvas) canvas.style.display = 'none';
      if (fallbackContainer) fallbackContainer.classList.remove('hidden');
      if (document?.body) {
          document.body.classList.add('fallback-mode');
      }
      if (loader) {
          loader.textContent = DEFAULT_LOADER_TEXT;
          loader.classList.add('hidden');
      }

  }

  if (force3dBtn) {
      force3dBtn.addEventListener('click', () => {
          start(true);
      });
  }

  function triggerResize() {
      if (!container || !canvas) return;

      const isMobile = window.innerWidth < 768;
      const hardCap = isMobile ? 1.5 : 2.0;
      const maxDpr = window.devicePixelRatio || 1;
      const allowedDpr = Math.min(maxDpr, hardCap);
      
      currentDpr = Math.min(targetDpr, allowedDpr);

      const rect = container.getBoundingClientRect();

      // --- BUG FIX: Address Bar Ignore Logic ---
      // On mobile, if width is same but height changed slightly (URL bar), SKIP resize.
      const widthChanged = rect.width !== lastWidth;
      const heightDiff = Math.abs(rect.height - lastHeight);
      
      // If width hasn't changed, and height change is small (< 150px is typical UI chrome),
      // it's likely just the address bar. Don't re-render.
      if (isMobile && !widthChanged && heightDiff < 150 && lastHeight > 0) {
          return;
      }
      // ----------------------------------------

      lastWidth = rect.width;
      lastHeight = rect.height;

      // Invalidate cached canvas rect
      cachedCanvasRect = null;

      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && canvas && width > 0 && height > 0) {
          // Only resize if dimensions actually changed to avoid flicker
          if (canvas.width !== width || canvas.height !== height) {
              canvas.width = width;
              canvas.height = height;
              state.resize(width, height);
          }
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-GrÃ¶ÃŸenÃ¤nderung (z.B. FenstergrÃ¶ÃŸe) immer neu berechnen
      triggerResize();
      updateUICache(); // Re-calculate cache only when layout actually changes
    });
    if (container) resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    if (canvas) intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    if (!container || !canvas) return;

    // NEW: Keyboard Navigation for Accessibility
    canvas.addEventListener('keydown', (e) => {
        // Prevent scrolling the page when using arrows
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
        }

        if (!state) return;
        
        const speed = 5.0; // Adjust sensitivity
        
        switch(e.key) {
            case 'ArrowLeft':
                state.update_camera(speed, 0, 0); // Rotate Left
                break;
            case 'ArrowRight':
                state.update_camera(-speed, 0, 0); // Rotate Right
                break;
            case 'ArrowUp':
                state.update_camera(0, speed, 0); // Rotate Up
                break;
            case 'ArrowDown':
                state.update_camera(0, -speed, 0); // Rotate Down
                break;
            case '+':
            case '=':
                state.update_camera(0, 0, -speed); // Zoom In
                break;
            case '-':
            case '_':
                state.update_camera(0, 0, speed); // Zoom Out
                break;
        }
    });

    container.addEventListener('pointerdown', (e: PointerEvent) => {
      if (!state) return;

      evCache.push(e);

      // If multi-touch, skip dragging logic (handled in pointermove)
      if (evCache.length > 1) {
          isDragging = false;
          return;
      }

      const blobActive = isBlobActive.get();
      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Priority: 1. Start dragging blob
      if (blobActive && state.startDragBlob && state.startDragBlob(x, y, rect.width, rect.height)) {
        isDraggingBlob = true;
        isDragging = false; // Prevent camera drag
        e.preventDefault();
        e.stopPropagation();
        container.setPointerCapture(e.pointerId);
        container.style.cursor = 'grabbing';
      }
      // Priority: 2. Start dragging camera
      else {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        container.style.cursor = 'grabbing';
        container.setPointerCapture(e.pointerId);
      }
    });

    const handlePointerUp = (e: PointerEvent) => {
      // Remove from cache
      const index = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
      if (index > -1) {
          evCache.splice(index, 1);
      }
      
      // Reset pinch state
      if (evCache.length < 2) {
          prevDiff = -1;
      }

      // Re-anchor if going from 2 -> 1 touches
      if (evCache.length === 1) {
          lastX = evCache[0].clientX;
          lastY = evCache[0].clientY;
          // Resume dragging only if we were not dragging blob
          if (!isDraggingBlob) {
              isDragging = true;
          }
      }

      if (isDraggingBlob && state && state.stopDragBlob) {
        state.stopDragBlob();
        isDraggingBlob = false;
      }
      
      if (evCache.length === 0) {
          isDragging = false;
          if (container) {
            container.style.cursor = 'grab';
            if (container.hasPointerCapture(e.pointerId)) {
              container.releasePointerCapture(e.pointerId);
            }
          }
      }
    };

    window.addEventListener('pointerup', handlePointerUp);
    window.addEventListener('pointercancel', handlePointerUp);
    window.addEventListener('pointerleave', handlePointerUp);

    container.addEventListener('pointermove', (e: PointerEvent) => {
      if (!state || !canvas) return;

      // Update cache
      const index = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
      if (index > -1) {
          evCache[index] = e;
      }

      // Multi-touch Pinch-to-Zoom
      if (evCache.length === 2) {
          const dx = evCache[1].clientX - evCache[0].clientX;
          const dy = evCache[1].clientY - evCache[0].clientY;
          const curDiff = Math.hypot(dx, dy);

          if (prevDiff > 0) {
              const delta = prevDiff - curDiff;
              // Zoom sensitivity: positive delta = pinch in (zoom out) -> increase radius
              state.update_camera(0, 0, delta * 3.0);
          }
          prevDiff = curDiff;
          
          // Reset drag state during zoom
          isDragging = false;
          return;
      }

      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;

      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // SOTA: Spawn blob on first mouse move to prevent initial position glitch
      if (isBlobActive.get() && !hasSpawnedSinceActive && state.spawnBlob) {
        state.spawnBlob(x, y, rect.width, rect.height);
        hasSpawnedSinceActive = true;
      }

      if (isDragging && !isDraggingBlob) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        state.update_camera(deltaX * 1.0, deltaY * 1.0, 0);
        lastX = e.clientX;
        lastY = e.clientY;
      }


      if (isDraggingBlob) {
        state.update(x, y, rect.width, rect.height);
      }

      if (isBlobActive.get() && !isDraggingBlob && !isDragging) {
        if (state.isHoveringBlob && state.isHoveringBlob(x, y, rect.width, rect.height)) {
          container.style.cursor = 'grab';
        } else {
          container.style.cursor = 'default';
        }
      } else if (isDraggingBlob) {
        container.style.cursor = 'grabbing';
      }
    });

    container.addEventListener('wheel', (e: WheelEvent) => {
      if (state) {
        e.preventDefault();
        if (isBlobActive.get() && isDraggingBlob && state.updateBlobY) {
          state.updateBlobY(e.deltaY);
        } else {
          state.update_camera(0, 0, e.deltaY * 0.5);
        }
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (blobUnsub) blobUnsub();
    if (timeUnsub) timeUnsub();
    if (layerUnsub) layerUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: transparent;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

#webgpu-canvas:focus-visible {
  outline: 2px solid rgba(255, 255, 255, 0.5);
  outline-offset: -2px;
}

.time-display {
  position: absolute;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Courier New', monospace; /* Tech/Digital feel */
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: 0.1rem;
  z-index: 10; /* Above canvas */
  pointer-events: none;
  transition: color 1s ease, text-shadow 1s ease;
}

.fallback-container {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    background: transparent;
    z-index: 5;
    padding-top: 12vh; /* place fallback text/button in upper third */
}

.fallback-container.hidden {
    display: none;
}

.loader {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.45);
    color: #fff;
    font-weight: 600;
    letter-spacing: 0.05em;
    z-index: 6;
    text-transform: uppercase;
}

.loader.hidden {
    display: none;
}

.fallback-controls {
    margin-top: 2rem;
    text-align: center;
}

.force-btn {
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.4);
    color: inherit;
    border-radius: 8px;
    backdrop-filter: blur(10px);
    cursor: pointer;
    transition: all 0.2s;
}

@supports not (backdrop-filter: blur(1px)) {
    .force-btn {
        backdrop-filter: none;
        background: rgba(255, 255, 255, 0.25);
    }
}


/* Mobile Landscape Fixes */
@media (max-height: 600px) and (orientation: landscape) {
    .fallback-controls {
        margin-top: 0.5rem;
    }
    
    .fallback-controls p {
        margin: 0.25rem 0;
        font-size: 0.9rem;
    }

    .force-btn {
        padding: 6px 12px;
        font-size: 0.9rem;
    }
}
</style>
