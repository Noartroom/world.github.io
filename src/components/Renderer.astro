---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, IMAGE3D-1, dezimiertt-glb-03
const { modelPath = "/models/modernart1-sculpt-1.glb" } = Astro.props;
---
<div 
  class="renderer-container" 
  id="renderer-container-id"
  data-canvas-id={CANVAS_ID}
  data-model-path={modelPath}
  aria-label="Interactive 3D Model Viewer" 
  role="application">
  <div 
    id="loader" 
    class="loader"
  >INITIALIZING GPU...</div>
  <div
    id="debug-overlay"
    style="position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none; font-family: monospace; z-index: 9999;">
      Waiting for audio data...
  </div>

  <div
    id="time-display"
    class="time-display"
  ></div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
  <div class="css-light-overlay"></div>
</div>

<script>
  // @ts-ignore
  import init, { startRenderer } from 'public/pkg/model_renderer.js?v=gpu_fix_6'; /* adjust path for prod/dev */
  import { theme, activeModel, onSet, isDynamicLightActive, isBlobActive } from '../lib/stores/sceneStore';
  import { getAudioData, getStereoData, getComprehensiveAudioAnalysis } from '../lib/stores/audioStore';
  import { timeStore } from '../lib/stores/timeStore';

    // DOM Elemente
  const container = document.getElementById('renderer-container-id');
  const CANVAS_ID = container?.dataset.canvasId;
  const modelPath = container?.dataset.modelPath;
  // --- Global Scope (f√ºr Cleanup notwendig) ---
  let state: any = null;
  let rafId: number | null = null;
  let resizeObserver: ResizeObserver | null = null;
  let intersectionObserver: IntersectionObserver | null = null;
  let isVisible = true;
  let themeUnsub: (() => void) | null = null;
  let lightUnsub: (() => void) | null = null;
  let blobUnsub: (() => void) | null = null;
  let modelUnsub: (() => void) | null = null;
  let timeUnsub: (() => void) | null = null;
  let isLoadingModel = false; // Prevent concurrent model loads

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  let frameTimer = 0;
  let frameCount = 0;
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;

  // DOM Elemente
  const canvas: HTMLCanvasElement | null = CANVAS_ID ? document.getElementById(CANVAS_ID) as HTMLCanvasElement : null;
  const loader = document.getElementById('loader');

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let isDraggingBlob = false;
  let hasSpawnedSinceActive = false; // Prevents re-spawning on every mouse move
  
  // Performance: Cache DOM queries and computed values
  let cachedCanvasRect: DOMRect | null = null;
  let lastCachedRectTime = 0;
  const RECT_CACHE_DURATION = 100; // Cache rect for 100ms

  // --- SOTA Render Loop ---
  function renderLoop(timestamp: number) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas || !canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Monitor Frame Time
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Einfacher FPS Counter √ºber 1 Sekunde
    frameTimer += delta;
    frameCount++;
    
    if (frameTimer >= 1000) {
      const fps = frameCount;
      // console.log(`FPS: ${fps}, DPR: ${currentDpr.toFixed(2)}`);
      
      // Dynamic Resolution Scaling (Tiered)
      // Wenn FPS unter 45 fallen, reduziere Aufl√∂sung (min 0.5)
      if (fps < 45 && currentDpr > 0.5) {
         targetDpr = Math.max(0.5, currentDpr - 0.25);
         triggerResize(); // Trigger resize with new DPR
      }
      // Wenn FPS stabil bei 60 sind, versuche Qualit√§t zu erh√∂hen (bis native DPR)
      else if (fps >= 58 && currentDpr < (window.devicePixelRatio || 1)) {
         targetDpr = Math.min(window.devicePixelRatio || 1, currentDpr + 0.1);
         triggerResize();
      }
      
      frameTimer = 0;
      frameCount = 0;
    }

    if (state) {
      try {
        // Pass audio data to WASM
        try {
            const audioData = getAudioData();
            const stereo = getStereoData();

            if (audioData && audioData.length > 0 && audioData instanceof Uint8Array) {
                const sum = audioData.reduce((a, b) => a + b, 0);
                const avg = sum / audioData.length;
                
                // avg is roughly 0-100, max 255.
                const intensity = Math.min(avg / 80.0, 1.0); // Increased sensitivity

                // Audio intensity is kept for visual effects only (no position changes)
                // Light position is purely user-controlled via drag

                // Enhanced Audio Analysis & Debug Output
                const debugEl = document.getElementById('debug-overlay');
                if (debugEl && frameCount % 10 === 0) {
                    // Get comprehensive audio analysis
                    const audioAnalysis = getComprehensiveAudioAnalysis();
                    const { frequencyBands, rmsEnergy, spatial, spectralCentroid, spectralRolloff, peakFrequency, zeroCrossingRate } = audioAnalysis;
                    
                    // Calculate balance for display
                    const totalVol = (stereo.left + stereo.right) || 1;
                    const balance = (stereo.right - stereo.left) / totalVol;
                    
                    debugEl.innerHTML = `
                        <div style="font-size: 10px; line-height: 1.4;">
                            <strong>AUDIO SIGNAL ANALYSIS</strong><br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Basic:</strong><br>
                            Intensity: ${intensity.toFixed(3)} | Avg: ${avg.toFixed(1)}<br>
                            L: ${stereo.left.toFixed(1)} | R: ${stereo.right.toFixed(1)}<br>
                            Balance: ${balance.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Frequency Bands:</strong><br>
                            Bass: ${frequencyBands.bass.toFixed(1)} | Mid: ${frequencyBands.mid.toFixed(1)} | Treble: ${frequencyBands.treble.toFixed(1)}<br>
                            <strong>RMS Energy:</strong><br>
                            B: ${rmsEnergy.bass.toFixed(3)} | M: ${rmsEnergy.mid.toFixed(3)} | T: ${rmsEnergy.treble.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spectral:</strong><br>
                            Centroid: ${spectralCentroid.toFixed(0)} Hz<br>
                            Rolloff: ${spectralRolloff.toFixed(0)} Hz<br>
                            Peak: ${peakFrequency.toFixed(0)} Hz<br>
                            ZCR: ${zeroCrossingRate.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spatial:</strong><br>
                            Width: ${spatial.stereoWidth.toFixed(3)}<br>
                            Phase: ${spatial.phaseDifference.toFixed(3)}<br>
                            Separation: ${spatial.channelSeparation.toFixed(3)}<br>
                            Azimuth: ${spatial.azimuth.toFixed(3)}
                        </div>
                    `;
                    debugEl.style.color = sum > 0 ? '#0f0' : '#f00';
                    
                    if (sum > 0) {
                        const borderAlpha = 0.3 + (intensity * 0.7);
                        const glowSize = 5 + (intensity * 20);
                        debugEl.style.border = `2px solid rgba(0, 255, 0, ${borderAlpha})`;
                        debugEl.style.boxShadow = `0 0 ${glowSize}px rgba(0, 255, 0, ${borderAlpha})`;
                    } else {
                        debugEl.style.border = 'none';
                        debugEl.style.boxShadow = 'none';
                    }
                }

                state.updateAudioData(audioData);

                // CSS overlay high emittance effect removed - only 3D cursor-directed lighting remains
            }
        } catch (audioErr) {
             console.warn("Audio Update Error (Non-fatal):", audioErr);
        }

        // --- PHASE 2: UI Repulsion (Blob -> UI) ---
        // Get blob position from Rust and push UI elements away
        if (state.getBlobScreenPosition) {
            if (isBlobActive.get()) {
                try {
                    const blobPos = state.getBlobScreenPosition();
                    // Check if we got a valid position (array length 2)
                    if (blobPos && blobPos.length === 2) {
                        const x = blobPos;
                        const y = blobPos;
                        
                        // Only apply if inside screen bounds
                        if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                             // Apply magnetic repulsion to UI elements
                             applyUIRepulsion(x, y);
                        } else {
                             resetUIRepulsion();
                        }
                    }
                } catch (err) {
                    // Ignore transient errors
                }
            } else {
                // Reset if blob is not active
                resetUIRepulsion();
            }
        }

        state.render();
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- UI Repulsion Logic ---
  function applyUIRepulsion(normalizedX: number, normalizedY: number) {
      // Find UI elements to repel (buttons, panels)
      const elements = document.querySelectorAll('.magnetic-ui');
      
      elements.forEach(el => {
          if (!(el instanceof HTMLElement)) return;
          
          const rect = el.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const blobX = normalizedX * window.innerWidth;
          const blobY = normalizedY * window.innerHeight;
          
          const dx = centerX - blobX;
          const dy = centerY - blobY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          const maxDist = 150; // Reduced radius to avoid accidental triggers
          
          if (dist < maxDist) {
              // Calculate repulsion force with smooth easing
              // Power function makes the falloff sharper, so effects only happen when closer
              const intensity = Math.pow(1 - dist / maxDist, 2);
              const force = intensity * 80; // Max 40px push
              const angle = Math.atan2(dy, dx);
              
              const moveX = Math.cos(angle) * force;
              const moveY = Math.sin(angle) * force;
              
              el.style.transform = `translate(${moveX}px, ${moveY}px)`;
          } else {
              el.style.transform = `translate(0px, 0px)`;
          }
      });
  }

  function resetUIRepulsion() {
      const elements = document.querySelectorAll('.magnetic-ui');
      elements.forEach(el => {
          if (el instanceof HTMLElement) {
              el.style.transform = `translate(0px, 0px)`;
          }
      });
  }

  // --- Time-of-Day System ---
  function updateTimeOfDay(currentHour: number) {
      if (!state || !state.setEnvironmentLight) return;
      
      // Calculate normalized time (0.0 - 1.0) based on hours
      // 0.0 = midnight, 0.5 = noon, 1.0 = midnight next day
      const time = currentHour / 24.0;
      
      // SOTA Palette: Strict White/Yellow/Orange as requested
      const moonlight = { r: 0.9, g: 0.95, b: 1.0 };     // White Moonlight (Night) - Clean White
      const moonlight_bright = { r: 1.0, g: 1.0, b: 1.0 }; // Pure White
      const dawn = { r: 1.0, g: 0.6, b: 0.2 };           // Touch of Orange (Sunrise)
      const noon = { r: 1.0, g: 0.95, b: 0.6 };          // Yellow Light (Day)
      const dusk = { r: 1.0, g: 0.5, b: 0.1 };           // Touch of Orange (Sunset)
      
      // Sky Background Colors (Ambient) - Neutralized to avoid purple/magenta
      // Strictly following the palette for ambient as well, but darker
      const sky_night = { r: 0.05, g: 0.05, b: 0.08 };   // Deep Neutral Blue-Black (No Purple)
      const sky_day = { r: 0.5, g: 0.7, b: 0.9 };        // Clear Sky Blue
      const sky_dawn = { r: 0.2, g: 0.15, b: 0.1 };      // Dark Warm Tone

      let light = { r: 0, g: 0, b: 0 };
      let sky = { r: 0, g: 0, b: 0 };
      
      if (time < 0.166) { // 00:00 - 04:00 (Moonlight getting brighter)
          const t = time / 0.166;
          light = lerpColor(moonlight, moonlight_bright, t); // Peak at 4am
          sky = sky_night;
      } else if (time < 0.25) { // 04:00 - 06:00 (Brightest Moon -> Dawn)
          const t = (time - 0.166) / 0.084;
          light = lerpColor(moonlight_bright, dawn, t);
          sky = lerpColor(sky_night, sky_dawn, t);
      } else if (time < 0.5) { // 06:00 - 12:00 (Dawn -> Noon)
          const t = (time - 0.25) / 0.25;
          light = lerpColor(dawn, noon, t);
          sky = lerpColor(sky_dawn, sky_day, t);
      } else if (time < 0.75) { // 12:00 - 18:00 (Noon -> Sunset)
          const t = (time - 0.5) / 0.25;
          light = lerpColor(noon, dusk, t);
          sky = lerpColor(sky_day, sky_dawn, t);
      } else { // 18:00 - 24:00 (Sunset -> Moonlight)
          const t = (time - 0.75) / 0.25;
          light = lerpColor(dusk, moonlight, t);
          sky = lerpColor(sky_dawn, sky_night, t);
      }
      
      state.setEnvironmentLight(
          sky.r, sky.g, sky.b,
          light.r, light.g, light.b
      );
  }
  
  function lerpColor(c1: any, c2: any, t: number) {
      return {
          r: c1.r + (c2.r - c1.r) * t,
          g: c1.g + (c2.g - c1.g) * t,
          b: c1.b + (c2.b - c1.b) * t
      };
  }

  // --- Initialization ---
  async function start() {
    if (!canvas) return;

    try {
      await init();
      state = await startRenderer(canvas);
      
      // 1. Theme Sync - Initialize lighting based on current theme
      if (theme) {
        const initialTheme = theme.get();
        state.setTheme(initialTheme === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) state.setTheme(newValue === 'dark');
        });
      }
      
      // 1.1 Time-of-Day Sync
      timeUnsub = timeStore.subscribe((value: number) => {
         updateTimeOfDay(value);
      });

      // 1.5 Dynamic Light Sync
      // Cursor-directed 3D lighting is enabled by default (controlled by isDynamicLightActive)
      // Initialize light position to center
      document.documentElement.style.setProperty('--light-x', '50vw');
      document.documentElement.style.setProperty('--light-y', '50vh');
      
      // Handle cursor-directed 3D lighting toggle
      // When disabled, cursor light should disappear (not stay at last position)
      lightUnsub = onSet(isDynamicLightActive, ({ newValue }) => {
         // Update cursor light active state in Rust
         if (state && state.setCursorLightActive) {
             state.setCursorLightActive(newValue);
         }
         // Toggle the CSS overlay to make the effect visible
         document.documentElement.style.setProperty('--light-opacity', newValue ? '0.9' : '0');
      });
      
      // Initialize cursor light state (enabled by default)
      if (state && state.setCursorLightActive) {
          const initialDynamicLight = isDynamicLightActive.get();
          state.setCursorLightActive(initialDynamicLight);
          document.documentElement.style.setProperty('--light-opacity', initialDynamicLight ? '0.9' : '0');
      }

      // Handle light blob spawning/despawning ONLY (separate from CSS lighting)
      blobUnsub = onSet(isBlobActive, ({ newValue }) => {
         if (!newValue && state?.despawnBlob) {
             state.despawnBlob();
             isDraggingBlob = false;
             hasSpawnedSinceActive = false; // Reset the flag so it can be spawned again if re-enabled
         }
      });

      // 1.6 Model Switching
      let isInitialLoad = true; // Track if we're doing the initial load
      let currentLoadedModel: string | null = null; // Track currently loaded model
      
      const loadModel = async (modelType: string) => {
        // Prevent concurrent loads
        if (isLoadingModel) {
          console.log(`Model load already in progress, skipping ${modelType}`);
          return;
        }

        // Skip if already loaded
        if (currentLoadedModel === modelType && !isInitialLoad) {
          console.log(`Model ${modelType} already loaded, skipping`);
          return;
        }

        // Ensure state is ready
        if (!state) {
          console.error('Cannot load model: renderer state not ready');
          return;
        }

        const modelPath = modelType === 'dark'
          ? '/models/dezimiertt-glb-03.glb'
          : '/models/modernart1-sculpt-1.glb';
        
        isLoadingModel = true;
        
        try {
          if (loader) {
            loader.classList.remove('hidden');
            loader.textContent = `LOADING ${modelType.toUpperCase()} MODEL...`;
          }
          
          const response = await fetch(modelPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const bytes = new Uint8Array(await response.arrayBuffer());
          
          // Small delay to ensure renderer is ready (fixes first-click issue)
          if (isInitialLoad) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          state.loadModelFromBytes(bytes);
          
          // Wait a bit for the model to be processed
          await new Promise(resolve => setTimeout(resolve, 50));
          
          currentLoadedModel = modelType; // Track what we loaded
          
          if (loader) {
            loader.classList.add('hidden');
          }
          console.log(`Model switched to: ${modelType}`);
        } catch (e) {
          console.error(`Failed to load model ${modelType}:`, e);
          if (loader) {
            loader.textContent = `ERROR LOADING ${modelType.toUpperCase()}`;
            // Auto-hide error after 3 seconds
            setTimeout(() => {
              if (loader) loader.classList.add('hidden');
            }, 3000);
          }
        } finally {
          isLoadingModel = false;
          if (isInitialLoad) {
            isInitialLoad = false;
          }
        }
      };

      // Load initial model (wait for it to complete before setting up subscription)
      const initialModel = activeModel.get();
      await loadModel(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue }) => {
        // Skip if this is the initial value being set or if already loading
        if (isInitialLoad || isLoadingModel) {
          return;
        }
        
        // Only load if state is ready and value actually changed
        if (state && newValue !== currentLoadedModel) {
          loadModel(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      rafId = requestAnimationFrame(renderLoop);

    } catch (e: any) {
      console.group("üî¥ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      if (loader) loader.textContent = "GPU ERROR: " + e; // Zeige Fehler im UI an
      // Ensure we kill any zombie loops
      cleanup();
    }
  }

  function triggerResize() {
      if (!container || !canvas) return;
      // Manuelles Update, respektiert targetDpr
      currentDpr = targetDpr;
      const rect = container.getBoundingClientRect();
      // Invalidate cached canvas rect when resizing
      cachedCanvasRect = null;
      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && canvas && width > 0 && height > 0) {
          canvas.width = width;
          canvas.height = height;
          state.resize(width, height);
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-Gr√∂√üen√§nderung (z.B. Fenstergr√∂√üe) immer neu berechnen
      triggerResize();
    });
    if (container) resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    if (canvas) intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    if (!container || !canvas) return;

    container.addEventListener('pointerdown', (e: PointerEvent) => {
      if (!state) return;

      const blobActive = isBlobActive.get();
      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Priority: 1. Start dragging blob
      if (blobActive && state.startDragBlob && state.startDragBlob(x, y, rect.width, rect.height)) {
        isDraggingBlob = true;
        isDragging = false; // Prevent camera drag
        e.preventDefault();
        e.stopPropagation();
        container.setPointerCapture(e.pointerId);
        container.style.cursor = 'grabbing';
      }
      // Priority: 2. Start dragging camera
      else {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        container.style.cursor = 'grabbing';
        container.setPointerCapture(e.pointerId);
      }
    });

    window.addEventListener('pointerup', (e: PointerEvent) => {
      if (isDraggingBlob && state && state.stopDragBlob) {
        state.stopDragBlob();
        isDraggingBlob = false;
      }
      if (isDragging) {
        isDragging = false;
      }
      if (container) {
        container.style.cursor = 'grab';
        if (container.hasPointerCapture(e.pointerId)) {
          container.releasePointerCapture(e.pointerId);
        }
      }
    });

    // SOTA: Update CSS light position globally on window to ensure it works over UI elements
    window.addEventListener('pointermove', (e: PointerEvent) => {
      if (isDynamicLightActive.get()) {
        document.documentElement.style.setProperty('--light-x', `${e.clientX}px`);
        document.documentElement.style.setProperty('--light-y', `${e.clientY}px`);
      }
    });

    container.addEventListener('pointermove', (e: PointerEvent) => {
      if (!state || !canvas) return;

      const now = performance.now();
      if (!cachedCanvasRect || (now - lastCachedRectTime) > RECT_CACHE_DURATION) {
        cachedCanvasRect = canvas.getBoundingClientRect();
        lastCachedRectTime = now;
      }
      const rect = cachedCanvasRect;

      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // SOTA: Spawn blob on first mouse move to prevent initial position glitch
      if (isBlobActive.get() && !hasSpawnedSinceActive && state.spawnBlob) {
        state.spawnBlob(x, y, rect.width, rect.height);
        hasSpawnedSinceActive = true;
      }

      if (isDragging && !isDraggingBlob) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        state.update_camera(deltaX * 1.0, deltaY * 1.0, 0);
        lastX = e.clientX;
        lastY = e.clientY;
      }


      const dynamicLightEnabled = isDynamicLightActive.get();
      if (dynamicLightEnabled || isDraggingBlob) {
        state.update(x, y, rect.width, rect.height);
      }

      if (isBlobActive.get() && !isDraggingBlob && !isDragging) {
        if (state.isHoveringBlob && state.isHoveringBlob(x, y, rect.width, rect.height)) {
          container.style.cursor = 'grab';
        } else {
          container.style.cursor = 'default';
        }
      } else if (isDraggingBlob) {
        container.style.cursor = 'grabbing';
      }
    });

    container.addEventListener('wheel', (e: WheelEvent) => {
      if (state) {
        e.preventDefault();
        if (isBlobActive.get() && isDraggingBlob && state.updateBlobY) {
          state.updateBlobY(e.deltaY);
        } else {
          state.update_camera(0, 0, e.deltaY * 0.5);
        }
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (lightUnsub) lightUnsub();
    if (modelUnsub) modelUnsub();
    if (timeUnsub) timeUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: transparent;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

.loader {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 2px;
  transition: opacity 0.5s ease;
  pointer-events: none; /* clicks go through */
  z-index: 10;
}
.loader.hidden { opacity: 0; }

.css-light-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none; /* clicks go through */
  opacity: var(--light-opacity, 0);
  transition: opacity 0.3s ease;
  /* Theme-based gradient: cool white for dark theme */
  background: radial-gradient(
    circle 800px at var(--light-x, 50%) var(--light-y, 50%),
    rgba(240, 245, 255, 0.9) 0%,
    rgba(200, 220, 255, 0.3) 40%,
    rgba(0, 0, 0, 0.0) 70%
  );
  mix-blend-mode: screen;
  z-index: 2; /* Ensure it's above the canvas */
}

.time-display {
  position: absolute;
  top: 2rem;
  left: 50%;
  transform: translateX(-50%);
  font-family: 'Courier New', monospace; /* Tech/Digital feel */
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: 0.1rem;
  z-index: 10; /* Above canvas */
  pointer-events: none;
  transition: color 1s ease, text-shadow 1s ease;
}
</style>