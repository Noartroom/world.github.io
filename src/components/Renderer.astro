---
// model_renderer/src/components/Renderer.astro
const CANVAS_ID = "webgpu-canvas";  // modernart1-sculpt-1, IMAGE3D-1, dezimiertt-glb-03
const { modelPath = "/models/modernart1-sculpt-1.glb" } = Astro.props;
---

<div class="renderer-container" aria-label="Interactive 3D Model Viewer" role="application">
  <div id="loader" class="loader">INITIALIZING GPU...</div>
  <div id="debug-overlay" style="position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: none; font-family: monospace; z-index: 9999;">
      Waiting for audio data...
  </div>
  
  <canvas id={CANVAS_ID} tabindex="0" aria-label="3D Canvas"></canvas>
  <div class="css-light-overlay"></div>
</div>

<script type="module" define:vars={{ CANVAS_ID, modelPath }}>
  import init, { startRenderer } from '/pkg/model_renderer.js?v=gpu_fix_6';
  import { theme, activeModel, onSet, isDynamicLightActive, isBlobActive } from '../src/stores/sceneStore.ts';
  import { getAudioData, getStereoData, getComprehensiveAudioAnalysis } from '../src/stores/audioStore.ts';

  // --- Global Scope (f√ºr Cleanup notwendig) ---
  let state = null;
  let rafId = null;
  let resizeObserver = null;
  let intersectionObserver = null;
  let isVisible = true;
  let themeUnsub = null;
  let lightUnsub = null;
  let blobUnsub = null;
  let modelUnsub = null;
  let isLoadingModel = false; // Prevent concurrent model loads

  // Performance Monitoring (SOTA Guardrails)
  let lastFrameTime = performance.now();
  let frameTimer = 0;
  let frameCount = 0;
  let currentDpr = typeof window !== 'undefined' ? (window.devicePixelRatio || 1) : 1;
  let targetDpr = currentDpr;

  // DOM Elemente
  const canvas = document.getElementById(CANVAS_ID);
  const container = document.querySelector('.renderer-container');
  const loader = document.getElementById('loader');

  // Input State
  let isDragging = false;
  let lastX = 0;
  let lastY = 0;
  let isDraggingBlob = false;

  // --- SOTA Render Loop ---
  function renderLoop(timestamp) {
    // 0. Safety: Stoppen, wenn Canvas nicht mehr im DOM ist (Astro View Transition)
    if (!canvas.isConnected) {
        cleanup();
        return;
    }

    // 1. Battery Saver: Pause, wenn Tab im Hintergrund oder Canvas off-screen
    if (!isVisible || document.hidden) {
      rafId = requestAnimationFrame(renderLoop);
      return;
    }

    // 2. Performance Guardrails: Monitor Frame Time
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Einfacher FPS Counter √ºber 1 Sekunde
    frameTimer += delta;
    frameCount++;
    
    if (frameTimer >= 1000) {
      const fps = frameCount;
      // console.log(`FPS: ${fps}, DPR: ${currentDpr.toFixed(2)}`);
      
      // Dynamic Resolution Scaling (Tiered)
      // Wenn FPS unter 45 fallen, reduziere Aufl√∂sung (min 0.5)
      if (fps < 45 && currentDpr > 0.5) {
         targetDpr = Math.max(0.5, currentDpr - 0.25);
         triggerResize(); // Trigger resize with new DPR
      }
      // Wenn FPS stabil bei 60 sind, versuche Qualit√§t zu erh√∂hen (bis native DPR)
      else if (fps >= 58 && currentDpr < (window.devicePixelRatio || 1)) {
         targetDpr = Math.min(window.devicePixelRatio || 1, currentDpr + 0.1);
         triggerResize();
      }
      
      frameTimer = 0;
      frameCount = 0;
    }

    if (state) {
      try {
        // Pass audio data to WASM
        try {
            const audioData = getAudioData();
            const stereo = getStereoData();

            if (audioData && audioData.length > 0 && audioData instanceof Uint8Array) {
                const sum = audioData.reduce((a, b) => a + b, 0);
                const avg = sum / audioData.length;
                
                // avg is roughly 0-100, max 255.
                const intensity = Math.min(avg / 80.0, 1.0); // Increased sensitivity

                // Audio intensity is kept for visual effects only (no position changes)
                // Light position is purely user-controlled via drag

                // Enhanced Audio Analysis & Debug Output
                const debugEl = document.getElementById('debug-overlay');
                if (debugEl && frameCount % 10 === 0) {
                    // Get comprehensive audio analysis
                    const audioAnalysis = getComprehensiveAudioAnalysis();
                    const { frequencyBands, rmsEnergy, spatial, spectralCentroid, spectralRolloff, peakFrequency, zeroCrossingRate } = audioAnalysis;
                    
                    // Calculate balance for display
                    const totalVol = (stereo.left + stereo.right) || 1;
                    const balance = (stereo.right - stereo.left) / totalVol;
                    
                    debugEl.innerHTML = `
                        <div style="font-size: 10px; line-height: 1.4;">
                            <strong>AUDIO SIGNAL ANALYSIS</strong><br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Basic:</strong><br>
                            Intensity: ${intensity.toFixed(3)} | Avg: ${avg.toFixed(1)}<br>
                            L: ${stereo.left.toFixed(1)} | R: ${stereo.right.toFixed(1)}<br>
                            Balance: ${balance.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Frequency Bands:</strong><br>
                            Bass: ${frequencyBands.bass.toFixed(1)} | Mid: ${frequencyBands.mid.toFixed(1)} | Treble: ${frequencyBands.treble.toFixed(1)}<br>
                            <strong>RMS Energy:</strong><br>
                            B: ${rmsEnergy.bass.toFixed(3)} | M: ${rmsEnergy.mid.toFixed(3)} | T: ${rmsEnergy.treble.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spectral:</strong><br>
                            Centroid: ${spectralCentroid.toFixed(0)} Hz<br>
                            Rolloff: ${spectralRolloff.toFixed(0)} Hz<br>
                            Peak: ${peakFrequency.toFixed(0)} Hz<br>
                            ZCR: ${zeroCrossingRate.toFixed(3)}<br>
                            <hr style="margin: 4px 0; border-color: #0f0;">
                            <strong>Spatial:</strong><br>
                            Width: ${spatial.stereoWidth.toFixed(3)}<br>
                            Phase: ${spatial.phaseDifference.toFixed(3)}<br>
                            Separation: ${spatial.channelSeparation.toFixed(3)}<br>
                            Azimuth: ${spatial.azimuth.toFixed(3)}
                        </div>
                    `;
                    debugEl.style.color = sum > 0 ? '#0f0' : '#f00';
                    
                    if (sum > 0) {
                        const borderAlpha = 0.3 + (intensity * 0.7);
                        const glowSize = 5 + (intensity * 20);
                        debugEl.style.border = `2px solid rgba(0, 255, 0, ${borderAlpha})`;
                        debugEl.style.boxShadow = `0 0 ${glowSize}px rgba(0, 255, 0, ${borderAlpha})`;
                    } else {
                        debugEl.style.border = 'none';
                        debugEl.style.boxShadow = 'none';
                    }
                }

                state.updateAudioData(audioData);

                // Update CSS light (completely independent of audio)
                // Light position is updated in pointermove handler
                const dynamicLightEnabled = isDynamicLightActive.get();
                
                if (container && dynamicLightEnabled) {
                   const overlay = container.querySelector('.css-light-overlay');
                   
                   if (overlay) {
                        const currentTheme = theme.get();
                        const isDark = currentTheme === 'dark';
                        
                        // Static opacity (no audio influence)
                        const baseOpacity = isDark ? 0.15 : 0.25;
                        overlay.style.opacity = baseOpacity.toFixed(2);
                        
                        // Theme-based color temperature (static, no audio)
                        let r, g, b;
                        if (isDark) {
                            r = 240;
                            g = 245;
                            b = 255;
                        } else {
                            r = 255;
                            g = 250;
                            b = 240;
                        }
                        
                        // Static radial gradient (position updated in pointermove)
                        overlay.style.background = `radial-gradient(
                            circle 1000px at var(--light-x, 50%) var(--light-y, 50%),
                            rgba(${r}, ${g}, ${b}, ${baseOpacity}) 0%,
                            rgba(${r}, ${g}, ${b}, ${baseOpacity * 0.6}) 30%,
                            rgba(0, 0, 0, 0.0) 70%
                        )`;
                   }
                   
                   // Static intensity (no audio influence)
                   document.documentElement.style.setProperty('--light-intensity', '1.0');
                   document.body.classList.add('light-engine-active');
                }
            }
        } catch (audioErr) {
             console.warn("Audio Update Error (Non-fatal):", audioErr);
        }

        state.render();
      } catch (e) {
        console.error("Render Crash:", e);
        cleanup(); // Notfall-Cleanup
        return;
      }
    }
    rafId = requestAnimationFrame(renderLoop);
  }

  // --- Initialization ---
  async function start() {
    if (!canvas) return;

    try {
      await init();
      state = await startRenderer(canvas);
      
      // 1. Theme Sync - Initialize lighting based on current theme
      if (theme) {
        const initialTheme = theme.get();
        state.setTheme(initialTheme === 'dark');
        themeUnsub = onSet(theme, ({ newValue }) => {
            if (state) state.setTheme(newValue === 'dark');
        });
      }

      // 1.5 Dynamic Light Sync
      // Initialize light position to center
      document.documentElement.style.setProperty('--light-x', '50vw');
      document.documentElement.style.setProperty('--light-y', '50vh');
      document.documentElement.style.setProperty('--light-intensity', '0');
      
      // Handle cursor-directed CSS lighting ONLY (no blob interaction)
      lightUnsub = onSet(isDynamicLightActive, ({ newValue }) => {
         if (!newValue && container) {
             const overlay = container.querySelector('.css-light-overlay');
             if (overlay) overlay.style.opacity = '0';
             document.body.classList.remove('light-engine-active');
             // Keep CSS vars but zero intensity for smooth transitions
             document.documentElement.style.setProperty('--light-intensity', '0');
         } else if (newValue) {
             // Ensure class is added when enabled and initialize position
             document.body.classList.add('light-engine-active');
             // Initialize to center if not already set
             if (!document.documentElement.style.getPropertyValue('--light-x')) {
               document.documentElement.style.setProperty('--light-x', '50vw');
               document.documentElement.style.setProperty('--light-y', '50vh');
             }
         }
      });

      // Handle light blob spawning/despawning ONLY (separate from CSS lighting)
      blobUnsub = onSet(isBlobActive, ({ newValue }) => {
         if (!newValue && state) {
             // Despawn blob
             if (state.despawnBlob) {
                 state.despawnBlob();
             }
             isDraggingBlob = false;
         } else if (newValue && state) {
             // Spawn blob at top of scene
             if (state.spawnBlob) {
                 state.spawnBlob();
             }
         }
      });

      // 1.6 Model Switching
      let isInitialLoad = true; // Track if we're doing the initial load
      let currentLoadedModel = null; // Track currently loaded model
      
      const loadModel = async (modelType) => {
        // Prevent concurrent loads
        if (isLoadingModel) {
          console.log(`Model load already in progress, skipping ${modelType}`);
          return;
        }

        // Skip if already loaded
        if (currentLoadedModel === modelType && !isInitialLoad) {
          console.log(`Model ${modelType} already loaded, skipping`);
          return;
        }

        // Ensure state is ready
        if (!state) {
          console.error('Cannot load model: renderer state not ready');
          return;
        }

        const modelPath = modelType === 'dark' 
          ? '/models/dezimiertt-glb-03.glb' 
          : '/models/modernart1-sculpt-1.glb';
        
        isLoadingModel = true;
        
        try {
          if (loader) {
            loader.classList.remove('hidden');
            loader.textContent = `LOADING ${modelType.toUpperCase()} MODEL...`;
          }
          
          const response = await fetch(modelPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const bytes = new Uint8Array(await response.arrayBuffer());
          
          // Small delay to ensure renderer is ready (fixes first-click issue)
          if (isInitialLoad) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
          
          state.loadModelFromBytes(bytes);
          
          // Wait a bit for the model to be processed
          await new Promise(resolve => setTimeout(resolve, 50));
          
          currentLoadedModel = modelType; // Track what we loaded
          
          if (loader) {
            loader.classList.add('hidden');
          }
          console.log(`Model switched to: ${modelType}`);
        } catch (e) {
          console.error(`Failed to load model ${modelType}:`, e);
          if (loader) {
            loader.textContent = `ERROR LOADING ${modelType.toUpperCase()}`;
            // Auto-hide error after 3 seconds
            setTimeout(() => {
              if (loader) loader.classList.add('hidden');
            }, 3000);
          }
        } finally {
          isLoadingModel = false;
          if (isInitialLoad) {
            isInitialLoad = false;
          }
        }
      };

      // Load initial model (wait for it to complete before setting up subscription)
      const initialModel = activeModel.get();
      await loadModel(initialModel);

      // Subscribe to model changes (only after initial load is complete)
      modelUnsub = onSet(activeModel, ({ newValue, oldValue }) => {
        // Skip if this is the initial value being set or if already loading
        if (isInitialLoad || isLoadingModel) {
          return;
        }
        
        // Only load if state is ready and value actually changed
        if (state && newValue !== oldValue && newValue !== currentLoadedModel) {
          loadModel(newValue);
        }
      });

      // 3. Systeme starten
      setupObservers();
      setupInput();
      
      // 4. Initial Resize erzwingen (Verhindert "Mini-Canvas" Blitz)
      triggerInitialResize();

      renderLoop();

    } catch (e) {
      console.group("üî¥ SOTA Renderer Error Log");
      console.error("Initialization failed. Details below:");
      if (e.stack) console.error("Stack:", e.stack);
      
      if (loader) loader.textContent = "GPU ERROR: " + e; // Zeige Fehler im UI an
      // Ensure we kill any zombie loops
      cleanup(); 
    }
  }

  function triggerResize() {
      // Manuelles Update, respektiert targetDpr
      currentDpr = targetDpr;
      const rect = container.getBoundingClientRect();
      const width = Math.max(1, Math.floor(rect.width * currentDpr));
      const height = Math.max(1, Math.floor(rect.height * currentDpr));
      
      if (state && width > 0 && height > 0) {
          canvas.width = width;
          canvas.height = height;
          state.resize(width, height);
      }
  }

  function triggerInitialResize() {
      triggerResize();
  }

  // --- Observers (Resize & Visibility) ---
  function setupObservers() {
    // Resize Observer
    resizeObserver = new ResizeObserver(entries => {
      // Bei Container-Gr√∂√üen√§nderung (z.B. Fenstergr√∂√üe) immer neu berechnen
      triggerResize();
    });
    resizeObserver.observe(container);

    // Intersection Observer (Pausiert Render Loop wenn unsichtbar)
    intersectionObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        isVisible = entry.isIntersecting;
      });
    }, { threshold: 0 });
    intersectionObserver.observe(canvas);
  }

  // --- Input Handling (Pointer Events) ---
  function setupInput() {
    container.addEventListener('pointerdown', (e) => {
      console.log("üñ±Ô∏è Pointer Down auf Renderer");
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      
      container.style.cursor = 'grabbing';
      // WICHTIG: Input sperren, damit Drehen auch au√üerhalb des Fensters geht
      container.setPointerCapture(e.pointerId);
    });

    window.addEventListener('pointerup', (e) => {
      // Clear click timeout if dragging happened
      if (blobClickTimeout) {
        clearTimeout(blobClickTimeout);
        blobClickTimeout = null;
      }
      
      if (isDraggingBlob && state && state.stopDragBlob) {
        state.stopDragBlob();
        isDraggingBlob = false;
      }
      isDragging = false;
      container.style.cursor = 'grab';
      if (container.hasPointerCapture(e.pointerId)) {
        container.releasePointerCapture(e.pointerId);
      }
    });
    
    // Handle blob click and drag start
    let blobClickTimeout = null;
    container.addEventListener('pointerdown', (e) => {
      if (!state) return;
      
      // Only handle blob interactions if blob is active
      const blobActive = isBlobActive.get();
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Try to start dragging blob first (if near blob, allow dragging)
      if (blobActive && state.startDragBlob && state.startDragBlob(x, y, rect.width, rect.height)) {
        isDraggingBlob = true;
        isDragging = false; // Don't drag camera when dragging blob
        e.preventDefault();
        e.stopPropagation();
        container.setPointerCapture(e.pointerId);
        
        // Set a timeout to toggle light on click (if no drag movement happens)
        blobClickTimeout = setTimeout(() => {
          if (state.checkBlobClick) {
            state.checkBlobClick(x, y, rect.width, rect.height);
          }
        }, 200); // 200ms delay to distinguish click from drag
        return;
      }
      
      // Otherwise, start camera drag
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      container.style.cursor = 'grabbing';
    });

    container.addEventListener('pointermove', (e) => {
      const rect = canvas.getBoundingClientRect();

      // If dragging blob, cancel click timeout
      if (isDraggingBlob && blobClickTimeout) {
        clearTimeout(blobClickTimeout);
        blobClickTimeout = null;
      }

      if (state && isDragging && !isDraggingBlob) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;
        
        const sensitivity = 1.0;
        state.update_camera(deltaX * sensitivity, deltaY * sensitivity, 0);

        lastX = e.clientX;
        lastY = e.clientY;
      }

      // Shader & CSS Overlay Update
      if (state) {
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Update blob position if dragging
        if (isBlobActive.get() && isDraggingBlob) {
          state.update(x, y, rect.width, rect.height);
        }
        
        // Update cursor-directed CSS lighting if enabled (separate from blob)
        if (isDynamicLightActive.get()) {
            // Update cursor light position (always tracks cursor for CSS)
            state.update(x, y, rect.width, rect.height);
            
            // Project cursor-directed 3D light position to 2D screen space for CSS
            // This always uses cursor position, never blob position
            if (state.getLightScreenPos) {
                const screenPos = state.getLightScreenPos();
                const screenX = screenPos[0]; // 0-1 range
                const screenY = screenPos[1]; // 0-1 range
                
                // Convert to viewport units for CSS
                const xPercent = screenX * 100;
                const yPercent = screenY * 100;
                
                // Update CSS variables for HTML elements (no audio-directed manipulation)
                document.documentElement.style.setProperty('--light-x', `${xPercent}vw`);
                document.documentElement.style.setProperty('--light-y', `${yPercent}vh`);
                
                // Also update container overlay (for backward compatibility)
                container.style.setProperty('--light-x', `${screenX * window.innerWidth}px`);
                container.style.setProperty('--light-y', `${screenY * window.innerHeight}px`);
            } else {
                // Fallback: use mouse position directly (only if blob doesn't exist)
                const xPercent = (e.clientX / window.innerWidth) * 100;
                const yPercent = (e.clientY / window.innerHeight) * 100;
                document.documentElement.style.setProperty('--light-x', `${xPercent}vw`);
                document.documentElement.style.setProperty('--light-y', `${yPercent}vh`);
                container.style.setProperty('--light-x', `${e.clientX}px`);
                container.style.setProperty('--light-y', `${e.clientY}px`);
            }
        }
      }
    });

    container.addEventListener('wheel', (e) => {
      if (state) {
        e.preventDefault();
        state.update_camera(0, 0, e.deltaY * 0.5); 
      }
    }, { passive: false });
  }

  // --- Cleanup ---
  function cleanup() {
    if (rafId) cancelAnimationFrame(rafId);
    if (resizeObserver) resizeObserver.disconnect();
    if (intersectionObserver) intersectionObserver.disconnect();
    if (themeUnsub) themeUnsub();
    if (lightUnsub) lightUnsub();
    if (modelUnsub) modelUnsub();
    
    if (state && state.free) state.free();
    state = null;
  }

  start();

  // Astro Lifecycle Support
  document.addEventListener('astro:before-swap', cleanup);
</script>

<style>
.renderer-container {
  position: fixed;
  inset: 0;
  z-index: -1;
  background: transparent;
  cursor: grab;
  overflow: hidden;
  pointer-events: auto; /* clickable container for camera */
  /* Mobile UX: Verhindert Textauswahl beim Drehen */
  user-select: none; 
  -webkit-user-select: none;
  
  /* SOTA FIX: Verhindert Page-Scroll beim Draggen des Overlays */
  touch-action: none; 
}

#webgpu-canvas {
  display: block;
  width: 100%;
  height: 100%;
  outline: none;
}

.loader {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  color: #666;
  font-family: monospace;
  font-size: 12px;
  letter-spacing: 2px;
  transition: opacity 0.5s ease;
  pointer-events: none; /* clicks go through */
  z-index: 10;
}
.loader.hidden { opacity: 0; }

.css-light-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none; /* clicks go through */
  opacity: var(--light-opacity, 0);
  transition: opacity 0.1s ease;
  background: radial-gradient(
    circle 800px at var(--light-x, 50%) var(--light-y, 50%),
    rgba(100, 150, 255, 0.6) 0%,
    rgba(50, 80, 200, 0.2) 40%,
    rgba(0, 0, 0, 0.0) 70%
  );
  mix-blend-mode: screen;
  z-index: 2; /* Ensure it's above the canvas */
}
</style>